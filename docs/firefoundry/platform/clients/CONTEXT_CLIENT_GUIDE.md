# Context Service Client - Developer Guide

_Generated by Claude_

## Table of Contents

1. [Overview](#overview)
2. [Installation](#installation)
3. [Quick Start](#quick-start)
4. [Authentication & Configuration](#authentication--configuration)
5. [Working Memory Operations](#working-memory-operations)
6. [Blob Storage Operations](#blob-storage-operations)
7. [MCP Operations](#mcp-operations)
8. [Advanced Features](#advanced-features)
9. [Complete Examples](#complete-examples)
10. [API Reference](#api-reference)
11. [Troubleshooting](#troubleshooting)

---

## Overview

The Context Service Client (`@firebrandanalytics/cs-client`) is a TypeScript/JavaScript client library for interacting with the FireFoundry Context Service. It provides a type-safe interface for managing working memory, blob storage, and MCP (Model Context Protocol) operations within the FireFoundry platform.

### Key Features

- **Working Memory Management**: Store and retrieve structured context data with automatic entity graph integration
- **Blob Storage**: Upload, download, and manage large binary files with streaming support
- **MCP Operations**: List tools, resources, and execute tool calls for AI agent interactions
- **Environment Routing**: Support for multi-environment deployments via Kong Gateway namespacing
- **Authentication**: Built-in API key support
- **Streaming**: Efficient handling of large files with progress tracking
- **Type Safety**: Full TypeScript support with Zod schemas

### Architecture Context

The Context Service is a core component of the FireFoundry platform:

- **Metadata Storage**: All entity graph data and working memory metadata persists in PostgreSQL
- **Binary Storage**: Large files and binary artifacts are stored in blob storage (Azure Blob Storage)
- **Communication**: Internal platform services use gRPC; external integrations use REST/WebSockets via the FF SDK
- **Entity System**: Working memory is tightly integrated with FireFoundry's entity graph for zero-code persistence

---

## Installation

```bash
npm install @firebrandanalytics/cs-client
```

### Prerequisites

- Node.js 16+ or TypeScript 5.4+
- Access to a FireFoundry Context Service instance
- API key (if authentication is enabled)

### Package Information

- **Latest Version**: 1.6.0
- **Registry**: GitHub Packages (`https://npm.pkg.github.com/`)
- **Repository**: `firebrandanalytics/ff-core-types`

---

## Quick Start

### Basic Client Creation

```typescript
import { ContextServiceClient } from '@firebrandanalytics/cs-client';

// Create a client with default settings (localhost:50051)
const client = new ContextServiceClient();

// Or specify a custom address
const client = new ContextServiceClient({
    address: 'http://your-context-service:50051'
});
```

### Your First Working Memory Record

```typescript
import { ContextServiceClient } from '@firebrandanalytics/cs-client';
import { randomUUID } from 'crypto';

async function quickStart() {
    const client = new ContextServiceClient();
    
    // Insert a working memory record
    const result = await client.insertWMRecord({
        entityNodeId: randomUUID(),
        memoryType: 'data/json',
        name: 'My First Record',
        description: 'A test record',
        content: {
            message: 'Hello, FireFoundry!'
        }
    });
    
    console.log('Created record:', result.id);
    
    // Fetch it back
    const record = await client.fetchWMRecord(result.id);
    console.log('Retrieved record:', record);
}
```

---

## Authentication & Configuration

### API Key Authentication

```typescript
const client = new ContextServiceClient({
    address: 'http://your-context-service:50051',
    apiKey: 'your-api-key'
});
```

### Environment/Namespace Routing

FireFoundry supports multi-environment deployments using Kong Gateway. The `environment` parameter maps to Kubernetes namespaces:

```typescript
// Route to the 'ff-dev' namespace
const client = new ContextServiceClient({
    address: 'http://kong-proxy:80',
    environment: 'ff-dev',
    apiKey: 'your-api-key'
});
```

### Dynamic Configuration

You can update the API key and environment after client creation:

```typescript
const client = new ContextServiceClient({
    address: 'http://kong-proxy:80'
});

// Later, configure authentication and environment
client.setApiKey('your-api-key');
client.setEnvironment('ff-prod');
```

### Per-Request Environment Override

```typescript
const client = new ContextServiceClient({
    address: 'http://kong-proxy:80',
    environment: 'ff-dev'
});

// Override environment for a specific request
const tools = await client.listTools('general', {
    headers: {
        'X-FF-Environment': 'ff-staging'
    }
});
```

### Singleton Pattern

For applications that need a single shared client instance:

```typescript
// Initialize once with configuration
const client = ContextServiceClient.getInstance({
    address: 'http://your-context-service:50051',
    apiKey: 'your-api-key'
});

// Subsequent calls return the same instance
const sameClient = ContextServiceClient.getInstance();
```

---

## Working Memory Operations

Working memory records are the primary way to store structured context data in FireFoundry. They integrate with the entity graph and support rich metadata.

### Insert a Working Memory Record

```typescript
const result = await client.insertWMRecord({
    entityNodeId: 'your-entity-id',
    memoryType: 'data/json',
    name: 'Meeting Notes',
    description: 'Q4 planning discussion',
    content: {
        date: '2025-10-23',
        participants: ['Alice', 'Bob'],
        action_items: ['Update roadmap', 'Schedule follow-up']
    },
    metadata: {
        tags: ['planning', 'q4'],
        priority: 'high'
    },
    reasoning: 'Recording key decisions from planning meeting'
});

console.log('Created record ID:', result.id);
```

### Fetch a Working Memory Record

```typescript
const record = await client.fetchWMRecord('record-id');

console.log('Name:', record.name);
console.log('Content:', JSON.parse(record.content));
console.log('Metadata:', JSON.parse(record.metadata));
```

### Fetch All Records for an Entity

```typescript
const response = await client.fetchWMRecordsByEntity('entity-node-id');

console.log(`Found ${response.records.length} records`);
response.records.forEach(record => {
    console.log(`- ${record.name} (${record.memoryType})`);
});
```

### Delete (Archive) a Working Memory Record

```typescript
const result = await client.deleteWMRecord('record-id');
console.log('Archived:', result.success);
```

**Note**: Deletion in FireFoundry is typically soft deletion (archiving). The record may still exist in the database but is marked as archived.

### Working Memory Types

Common memory types include:

- `code/typescript` - TypeScript code snippets or files
- `data/json` - Structured JSON data
- `image/png` - PNG images
- `file` - Generic file content

Define custom memory types as needed for your application.

---

## Blob Storage Operations

Blob storage is used for large binary files associated with working memory records. All blob operations automatically create or reference working memory records.

### Upload from Buffer

```typescript
const { workingMemoryId, blobKey } = await client.uploadBlobFromBuffer({
    entityNodeId: 'entity-id',
    memoryType: 'file',
    name: 'document.pdf',
    description: 'Quarterly report',
    contentType: 'application/pdf',
    buffer: Buffer.from(pdfData),
    metadata: {
        uploadedBy: 'user@example.com',
        department: 'finance'
    }
});

console.log('Uploaded blob:', blobKey);
console.log('Working memory ID:', workingMemoryId);
```

### Upload from Stream (Large Files)

For large files, streaming provides better memory efficiency and progress tracking:

```typescript
async function* fileStream() {
    // Read file in chunks
    for (const chunk of chunks) {
        yield chunk;
    }
}

const { workingMemoryId, blobKey } = await client.uploadBlobFromStream({
    entityNodeId: 'entity-id',
    memoryType: 'file',
    name: 'large-video.mp4',
    description: 'Training video',
    contentType: 'video/mp4',
    stream: fileStream(),
    totalSize: totalBytes,
    onProgress: (bytesUploaded) => {
        const percent = (bytesUploaded / totalBytes) * 100;
        console.log(`Upload: ${percent.toFixed(1)}%`);
    }
});
```

### Download Blob

```typescript
// Download with metadata
const { buffer, contentType, workingMemoryRecord } = await client.getBlobAsBuffer({
    key: 'blob-key',
    includeMetadata: true
});

console.log('Downloaded', buffer.length, 'bytes');
console.log('Content type:', contentType);
console.log('Record name:', workingMemoryRecord?.name);
```

### Download by Working Memory ID

```typescript
const { buffer, contentType, workingMemoryRecord } = await client.getContentAsBuffer({
    workingMemoryId: 'wm-id',
    includeMetadata: true
});
```

### List Blobs for an Entity

```typescript
const result = await client.listBlobs('entity-node-id');

console.log('Blob keys:', result.blobKeys);
result.blobKeys.forEach(key => {
    console.log(`- ${key}`);
});
```

### Delete a Blob

```typescript
// Delete by blob key
await client.deleteBlob({ blobKey: 'blob-key' });

// Or delete by working memory ID
await client.deleteBlob({ workingMemoryId: 'wm-id' });
```

**Note**: Deleting a blob archives the associated working memory record.

---

## MCP Operations

MCP (Model Context Protocol) operations enable AI agents to discover and execute tools and access resources.

### List Available Tools

```typescript
const response = await client.listTools('WM');  // Context type: WM, RAG, or History

console.log('Available tools:');
response.tools?.forEach(tool => {
    console.log(`- ${tool.name}: ${tool.description}`);
});
```

### List Available Resources

```typescript
const response = await client.listResources('RAG');

console.log('Available resources:');
response.resources?.forEach(resource => {
    console.log(`- ${resource.uri}: ${resource.name}`);
});
```

### Execute a Tool

```typescript
const result = await client.executeTool(
    'WM',           // Context type
    'query',        // Tool name
    {               // Parameters
        sql: `SELECT id, name FROM working_memory LIMIT 10`
    }
);

// Parse the result
const resultString = new TextDecoder().decode(result.result);
const data = JSON.parse(resultString);
console.log('Query results:', data);
```

### Context Types

- **WM** (Working Memory): Tools for querying and manipulating working memory
- **RAG** (Retrieval Augmented Generation): Tools for semantic search and retrieval
- **History**: Tools for accessing entity history and chat logs

---

## Advanced Features

### Fetch Working Memory Manifest

The manifest provides a hierarchical view of all working memory associated with an entity and its descendants:

```typescript
const manifest = await client.fetchWMManifest('root-node-id');

console.log('Manifest:', JSON.stringify(manifest, null, 2));
```

With filtering:

```typescript
const manifest = await client.fetchWMManifest('root-node-id', {
    memoryTypes: ['code/typescript', 'data/json'],
    subtypes: ['component'],
    semanticPurposes: ['documentation']
});
```

### Get Chat History

```typescript
const history = await client.getChatHistory('node-id');

console.log('Chat messages:', history.messages);
```

### RAG Query

Execute SQL queries against the RAG system:

```typescript
const result = await client.executeRAGQuery(
    'SELECT * FROM embeddings WHERE similarity > 0.8'
);

const data = new TextDecoder().decode(result.result);
console.log('RAG results:', JSON.parse(data));
```

### Fetch Entity History

```typescript
const history = await client.fetchEntityHistory('entity-id');

console.log('Entity events:', history.events);
```

---

## Complete Examples

### Example 1: Document Management System

```typescript
import { ContextServiceClient } from '@firebrandanalytics/cs-client';
import { randomUUID } from 'crypto';
import * as fs from 'fs';

async function documentManagement() {
    const client = new ContextServiceClient({
        apiKey: 'your-api-key'
    });
    
    const projectId = randomUUID();
    
    // Upload a document
    const fileBuffer = fs.readFileSync('./report.pdf');
    const { workingMemoryId, blobKey } = await client.uploadBlobFromBuffer({
        entityNodeId: projectId,
        memoryType: 'file',
        name: 'Q4 Report.pdf',
        description: 'Quarterly financial report',
        contentType: 'application/pdf',
        buffer: fileBuffer,
        metadata: {
            quarter: 'Q4',
            year: 2025,
            department: 'Finance'
        }
    });
    
    // Create metadata record
    await client.insertWMRecord({
        entityNodeId: projectId,
        memoryType: 'data/json',
        name: 'Document Metadata',
        description: 'Additional context for Q4 report',
        content: {
            reviewers: ['alice@example.com', 'bob@example.com'],
            status: 'draft',
            dueDate: '2025-11-01'
        }
    });
    
    // List all documents in the project
    const blobs = await client.listBlobs(projectId);
    console.log('Project documents:', blobs.blobKeys);
    
    // Retrieve all project records
    const records = await client.fetchWMRecordsByEntity(projectId);
    console.log(`Project has ${records.records.length} records`);
}
```

### Example 2: Code Artifact Storage

```typescript
async function storeCodeArtifact() {
    const client = new ContextServiceClient();
    
    const codeContent = `
export function calculateMetrics(data: number[]): Metrics {
    return {
        mean: data.reduce((a, b) => a + b) / data.length,
        max: Math.max(...data),
        min: Math.min(...data)
    };
}
`;
    
    const { workingMemoryId } = await client.uploadBlobFromBuffer({
        entityNodeId: 'project-entity-id',
        memoryType: 'code/typescript',
        name: 'metrics.ts',
        description: 'Data metrics calculation function',
        contentType: 'text/x-typescript',
        buffer: Buffer.from(codeContent),
        metadata: {
            language: 'typescript',
            category: 'analytics',
            author: 'ai-agent'
        },
        reasoning: 'Generated function for calculating statistical metrics on numeric data'
    });
    
    console.log('Code stored:', workingMemoryId);
}
```

### Example 3: Multi-Environment Deployment

```typescript
async function multiEnvironmentExample() {
    // Development environment
    const devClient = new ContextServiceClient({
        address: 'http://kong-proxy:80',
        environment: 'ff-dev',
        apiKey: process.env.DEV_API_KEY
    });
    
    // Create a record in dev
    const devRecord = await devClient.insertWMRecord({
        entityNodeId: 'test-entity',
        memoryType: 'data/json',
        name: 'Test Configuration',
        description: 'Dev environment config',
        content: { environment: 'development' }
    });
    
    // Production environment
    const prodClient = new ContextServiceClient({
        address: 'http://kong-proxy:80',
        environment: 'ff-prod',
        apiKey: process.env.PROD_API_KEY
    });
    
    // Create the same record structure in prod
    const prodRecord = await prodClient.insertWMRecord({
        entityNodeId: 'test-entity',
        memoryType: 'data/json',
        name: 'Test Configuration',
        description: 'Production environment config',
        content: { environment: 'production' }
    });
    
    console.log('Dev record:', devRecord.id);
    console.log('Prod record:', prodRecord.id);
}
```

---

## API Reference

### Client Constructor

```typescript
constructor(options?: ContextServiceClientOptions)
```

**Options:**
- `address?: string` - Context Service URL (default: `http://localhost:50051`)
- `apiKey?: string` - API key for authentication
- `environment?: string` - Target environment/namespace (default: `default`)

### Working Memory Methods

#### `insertWMRecord(input, options?)`
Create a new working memory record.

**Parameters:**
- `input: WorkingMemoryInput` - Record data
- `options?: Record<string, any>` - Optional call options

**Returns:** `Promise<InsertWMRecordResponse>` with `id` field

#### `fetchWMRecord(id, options?)`
Retrieve a working memory record by ID.

**Parameters:**
- `id: string` - Record ID
- `options?: Record<string, any>` - Optional call options

**Returns:** `Promise<FetchWMRecordResponse>`

#### `deleteWMRecord(id, options?)`
Archive a working memory record.

**Parameters:**
- `id: string` - Record ID
- `options?: Record<string, any>` - Optional call options

**Returns:** `Promise<DeleteWMRecordResponse>` with `success` field

#### `fetchWMRecordsByEntity(entityNodeId, options?)`
Get all working memory records for an entity.

**Parameters:**
- `entityNodeId: string` - Entity node ID
- `options?: Record<string, any>` - Optional call options

**Returns:** `Promise<FetchWMRecordsByEntityResponse>` with `records` array

### Blob Storage Methods

#### `uploadBlobFromBuffer(params, options?)`
Upload a file from a buffer.

**Parameters:**
- `params: UploadBlobParams`
  - `entityNodeId: string`
  - `memoryType: string`
  - `name: string`
  - `description: string`
  - `contentType: string`
  - `buffer: Buffer`
  - `metadata?: Record<string, unknown>`
  - `reasoning?: string`
- `options?: Record<string, any>`

**Returns:** `Promise<{ workingMemoryId: string; blobKey: string }>`

#### `uploadBlobFromStream(params, options?)`
Upload a large file with streaming and progress tracking.

**Parameters:** Similar to `uploadBlobFromBuffer` but with:
- `stream: AsyncIterable<Buffer> | Iterable<Buffer>`
- `totalSize: number`
- `onProgress?: (bytesUploaded: number) => void`

**Returns:** `Promise<{ workingMemoryId: string; blobKey: string }>`

#### `getBlobAsBuffer(params, options?)`
Download a blob by key.

**Parameters:**
- `params: { key: string; includeMetadata: boolean }`
- `options?: Record<string, any>`

**Returns:** `Promise<{ buffer: Buffer; contentType: string; workingMemoryRecord?: FetchWMRecordResponse }>`

#### `getContentAsBuffer(params, options?)`
Download blob content by working memory ID.

**Parameters:**
- `params: { workingMemoryId: string; includeMetadata: boolean }`
- `options?: Record<string, any>`

**Returns:** `Promise<ContentAsBufferResponse>`

#### `listBlobs(entityNodeId, options?)`
List all blob keys for an entity.

**Parameters:**
- `entityNodeId: string`
- `options?: Record<string, any>`

**Returns:** `Promise<ListBlobsResponse>` with `blobKeys` array

#### `deleteBlob(params, options?)`
Delete a blob by key or working memory ID.

**Parameters:**
- `params: { workingMemoryId?: string; blobKey?: string }`
- `options?: Record<string, any>`

**Returns:** `Promise<DeleteBlobResponse>` with `success` field

### MCP Methods

#### `listTools(contextType, options?)`
List available tools for a context type.

**Parameters:**
- `contextType: string` - 'WM', 'RAG', or 'History'
- `options?: Record<string, any>`

**Returns:** `Promise<ListToolsResponse>` with `tools` array

#### `listResources(contextType, options?)`
List available resources for a context type.

**Parameters:**
- `contextType: string`
- `options?: Record<string, any>`

**Returns:** `Promise<ListResourcesResponse>` with `resources` array

#### `executeTool(contextType, tool, parameters, options?)`
Execute a tool.

**Parameters:**
- `contextType: string`
- `tool: string` - Tool name
- `parameters: Record<string, string>` - Tool parameters
- `options?: Record<string, any>`

**Returns:** `Promise<ExecuteToolResponse>` with `result` bytes

### Advanced Methods

#### `fetchWMManifest(rootNodeId, filter?, options?)`
Get hierarchical working memory manifest.

**Parameters:**
- `rootNodeId: string`
- `filter?: { memoryTypes?: string[]; subtypes?: string[]; semanticPurposes?: string[] }`
- `options?: Record<string, any>`

**Returns:** `Promise<FetchWMManifestResponse>`

#### `getChatHistory(nodeId, options?)`
Retrieve chat history for a node.

**Parameters:**
- `nodeId: string`
- `options?: Record<string, any>`

**Returns:** `Promise<GetChatHistoryResponse>`

#### `executeRAGQuery(sql, options?)`
Execute a RAG SQL query.

**Parameters:**
- `sql: string`
- `options?: Record<string, any>`

**Returns:** `Promise<RAGQueryResponse>` with `result` bytes

#### `fetchEntityHistory(entityId, options?)`
Get entity event history.

**Parameters:**
- `entityId: string`
- `options?: Record<string, any>`

**Returns:** `Promise<FetchEntityHistoryResponse>`

### Configuration Methods

#### `setApiKey(apiKey)`
Update the API key.

**Parameters:**
- `apiKey: string | undefined`

#### `setEnvironment(environment)`
Update the target environment.

**Parameters:**
- `environment: string`

#### `static getInstance(options?)`
Get or create a singleton instance.

**Parameters:**
- `options?: ContextServiceClientOptions`

**Returns:** `ContextServiceClient`

---

## Troubleshooting

### Connection Issues

**Problem:** Cannot connect to Context Service

**Solutions:**
- Verify the service address is correct
- Check network connectivity and firewall rules
- Ensure the service is running: `kubectl get pods -n your-namespace`
- For local development, verify port forwarding: `kubectl port-forward svc/context-service 50051:50051`

### Authentication Errors

**Problem:** `Unauthenticated` or `PermissionDenied` errors

**Solutions:**
- Verify your API key is correct
- Check that the API key has not expired
- Ensure the `x-api-key` header is being set correctly
- For Kong routing, verify the environment name matches your namespace

### Environment Routing Issues

**Problem:** Requests routing to wrong environment

**Solutions:**
- Check the `X-FF-Environment` header value
- Verify Kong is configured for header-based routing
- Ensure the namespace exists in your Kubernetes cluster
- Use per-request overrides if needed

### Blob Size Mismatches

**Problem:** `Content size mismatch` errors during download

**Solutions:**
- Ensure `includeMetadata: true` is set when downloading
- Check blob storage backend is accessible
- Verify blob was uploaded completely
- Try re-uploading the file

### Memory Issues with Large Files

**Problem:** Out of memory errors with large blobs

**Solutions:**
- Use `uploadBlobFromStream` instead of `uploadBlobFromBuffer`
- Process downloads in streams rather than loading entire buffer
- Implement chunked processing for large files
- Increase Node.js heap size if necessary: `node --max-old-space-size=4096`

### TypeScript Type Errors

**Problem:** Type mismatches or missing types

**Solutions:**
- Ensure `@bufbuild/protobuf` and `zod` peer dependencies are installed
- Check TypeScript version compatibility (5.4+)
- Rebuild the package: `npm run build`
- Clear `node_modules` and reinstall

### Debugging Tips

1. **Enable verbose logging**: Check gRPC transport logs
2. **Inspect network traffic**: Use tools like `grpcurl` to test endpoints
3. **Verify entity relationships**: Use `fetchWMRecordsByEntity` to see all related records
4. **Check working memory metadata**: Use `includeMetadata: true` on downloads
5. **Test with simple operations first**: Start with `listTools` or basic record insertion

### Common Pitfalls

- **Forgetting to parse JSON content**: Working memory `content` and `metadata` fields are JSON strings
- **Not handling async properly**: All client methods return Promises
- **Mixing blob key and working memory ID**: Be consistent about which identifier you're using
- **Ignoring error types**: Use `instanceof ConnectError` to handle gRPC errors properly
- **Hard-coding environment**: Use configuration or environment variables for flexibility

### Getting Help

- **Documentation**: Review the [FireFoundry Platform documentation](docs/README.md)
- **Examples**: Check the `src/examples/` directory for reference implementations
- **GitHub Issues**: Report bugs or request features
- **Internal Support**: Contact your platform team for environment-specific issues

---

## Additional Resources

### Related Documentation

- [FireFoundry Platform Overview](../docs/README.md)
- [AgentSDK Documentation](../packages/agent-sdk/)
- [FF SDK Documentation](../packages/ff-sdk/)
- [Deployment Guide](../docs/deployment.md)

### Example Applications

All examples are in `packages/context-client/src/examples/`:

- `wm-basic-usage.ts` - Working memory CRUD operations
- `blob-basic-usage.ts` - Blob upload/download patterns
- `mcp-basic-usage.ts` - MCP tool execution
- `auth-example.ts` - Authentication and environment routing
- `wm-manifest-usage.ts` - Manifest fetching patterns

### Version History

See [CHANGELOG.md](CHANGELOG.md) for detailed version history.

**Latest Changes (v1.6.0):**
- Added `environment` parameter for Kong Gateway namespace routing
- Added `setEnvironment()` method for dynamic namespace switching
- Automatic `X-FF-Environment` header injection on all requests

---

**Generated by Claude**

_Last Updated: October 2025_
