# Entity Client Reference Guide

**Generated by Claude**

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Configuration Reference](#configuration-reference)
4. [Access Modes](#access-modes)
5. [URL Construction](#url-construction)
6. [Authentication & Security](#authentication--security)
7. [Request Flow](#request-flow)
8. [API Reference](#api-reference)
9. [Error Handling](#error-handling)
10. [Best Practices](#best-practices)
11. [Troubleshooting](#troubleshooting)

---

## Overview

The Entity Client (`@firebrandanalytics/entity-client`) provides HTTP/REST access to the FireFoundry Entity Service. It's designed to support both external consumers (through Kong API Gateway) and internal FireFoundry services (direct access).

### Key Features

- **Dual Access Modes**: External (Kong + auth) and Internal (direct, no auth)
- **Complete API Coverage**: 40+ methods covering all entity operations
- **Type Safety**: Full TypeScript support with proper overloads
- **Automatic Correlation**: Built-in distributed tracing support
- **Flexible Routing**: Configurable for various gateway configurations
- **Error Transformation**: Consistent FFError handling

### When to Use

- **External Mode**: For applications outside the Kubernetes cluster accessing through Kong
- **Internal Mode**: For FireFoundry services within the same Kubernetes cluster

---

## Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     External Consumer                        │
│                  (Outside Kubernetes)                        │
└────────────────────────┬────────────────────────────────────┘
                         │
                         │ HTTPS (port 30080)
                         │ + API Key Auth
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                      Kong Gateway                            │
│              (ff-control-plane namespace)                    │
│                  (Ingress Controller)                        │
└────────────────────────┬────────────────────────────────────┘
                         │
                         │ HTTP (internal)
                         │ Routes to environment namespace
                         ▼
        ┌────────────────────────────────────┐
        │      Environment Namespace         │
        │           (e.g., ff-dev)           │
        │                                    │
        │  ┌──────────────────────────────┐  │
        │  │     Entity Service           │  │
        │  │  (Kubernetes Service)        │  │
        │  └──────┬───────────────────────┘  │
        │         │                  ▲        │
        │         │                  │        │ HTTP (port 8080)
        │         │                  │        │ No Auth
        │         ▼                  │        │
        │  ┌──────────┐   ┌─────────────┐    │
        │  │PostgreSQL│   │   Agent     │    │
        │  │  (Entity │   │   Bundle    │    │
        │  │   Graph) │   │  (Internal  │    │
        │  │          │   │   Service)  │    │
        │  └──────────┘   └─────────────┘    │
        └────────────────────────────────────┘
```

**Key Architecture Points:**

- **ff-control-plane**: Single namespace containing Kong Gateway and other control plane services
- **Environment Namespaces**: Separate namespaces (ff-dev, ff-test, ff-staging, ff-prod) each containing:
  - Entity Service instance
  - PostgreSQL database (or shared database with namespace isolation)
  - Agent bundles and other services
- **Routing**: Kong in ff-control-plane routes requests to entity-service in target environment namespace

### Entity Graph Concept

The entity service manages a **graph database** stored in PostgreSQL:

- **Nodes**: Represent entities (agents, workflows, runnables, data objects)
- **Edges**: Represent relationships between entities
- **Properties**: Both nodes and edges have `data` fields for arbitrary JSON
- **Types**: Nodes have `general_type` and `specific_type` for classification
- **Scoping**: All entities are scoped to an `app_id` for multi-tenancy

---

## Configuration Reference

### Constructor Signature

```typescript
constructor(
  base_url: string,
  app_id: UUID,
  options?: RemoteEntityClientOptions
)
```

### Configuration Options

#### `mode?: 'external' | 'internal'`

**Default**: `'external'`

Determines how the client connects to the entity service.

- **`external`**: Routes through Kong API Gateway
  - Requires authentication via API key
  - Uses external port (default 30080, controlled by cloud ingress)
  - Includes namespace in URL path
  - Used by applications outside Kubernetes cluster
  
- **`internal`**: Direct connection to entity service
  - No authentication required (relies on Kubernetes network policies)
  - Uses internal port (default 8080)
  - No namespace in URL path
  - Used by services within the same Kubernetes cluster

**When to use external mode:**
- Third-party integrations
- External applications
- Client applications outside the cluster
- Development/testing from local machine

**When to use internal mode:**
- Agent bundles
- FireFoundry platform services
- Microservices within the cluster
- Services in the same Kubernetes namespace

---

#### `api_key?: string`

**Required for**: External mode  
**Optional for**: Internal mode (ignored if provided)

The API key for authenticating with Kong Gateway.

```typescript
// External mode - API key is required
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: process.env.FIREFOUNDRY_API_KEY,  // Required
    namespace: 'ff-dev'  // Environment namespace
  }
);

// Internal mode - API key not needed
const client = new RemoteEntityClient(
  'http://entity-service',
  app_id,
  {
    mode: 'internal'
    // api_key ignored even if provided
  }
);
```

**Authentication mechanism:**
- Added as `Authorization: Bearer {api_key}` header
- Validated by Kong before reaching entity service
- Not visible to entity service itself

**Error handling:**
- Constructor throws `FFError` if `mode='external'` and no `api_key` provided
- 401 Unauthorized if API key is invalid
- 403 Forbidden if API key lacks permissions

---

#### `namespace?: string`

**Required for**: External mode  
**Forbidden for**: Internal mode

The Kubernetes namespace containing the entity service.

```typescript
// External mode - namespace required
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: 'key',
    namespace: 'ff-dev'  // Required
  }
);

// Internal mode - namespace forbidden
const client = new RemoteEntityClient(
  'http://entity-service',
  app_id,
  {
    mode: 'internal'
    // namespace: 'ff-dev'  // Would throw error
  }
);
```

**Purpose:**
- Kong uses namespace for routing to correct service
- Supports multi-namespace deployments
- Enables namespace-level isolation

**Common values:**
- `'ff-dev'` - Development environment
- `'ff-test'` - Testing environment
- `'ff-staging'` - Staging environment
- `'ff-prod'` - Production environment
- Custom namespace per deployment

**Error handling:**
- Constructor throws `FFError` if `mode='external'` and no `namespace` provided
- Constructor throws `FFError` if `mode='internal'` and `namespace` provided

---

#### `timeout?: number`

**Default**: `200000` (200 seconds)

Request timeout in milliseconds.

```typescript
const client = new RemoteEntityClient(
  'http://entity-service',
  app_id,
  {
    mode: 'internal',
    timeout: 30000  // 30 seconds
  }
);
```

**Timeout behavior:**
- Applies to all HTTP requests
- Times out on both connection and response
- Throws error on timeout (transformed to FFError)

**Recommendations by operation:**
- **Simple queries**: 5-10 seconds
- **Graph traversal**: 30-60 seconds
- **Vector search**: 30-60 seconds
- **Batch operations**: 60-120 seconds
- **Complex UDFs**: 120-300 seconds

**Example with timeout handling:**
```typescript
const client = new RemoteEntityClient(
  'http://entity-service',
  app_id,
  { 
    mode: 'internal',
    timeout: 10000  // 10 seconds
  }
);

try {
  const node = await client.get_node(nodeId);
} catch (error) {
  if (error.message.includes('timeout')) {
    console.log('Request timed out after 10 seconds');
  }
}
```

---

#### `external_port?: number`

**Default**: `30080`  
**Used in**: External mode only  
**Controlled by**: Cloud-based ingress controller

The port on which Kong Gateway listens for external traffic.

```typescript
const client = new RemoteEntityClient(
  'http://gateway.example.com',
  app_id,
  {
    mode: 'external',
    api_key: 'key',
    namespace: 'ff-dev',
    external_port: 30080  // Default, can be omitted
  }
);
```

**Important notes:**
- **This port is controlled by the cloud-based ingress controller**, not Kong directly
- Different from internal Kubernetes service ports
- May vary by deployment environment
- Typically exposed via cloud load balancer

**When to customize:**
- Custom ingress controller configuration
- Non-standard cloud deployments
- Development environments with custom ports
- Behind additional proxies/load balancers

**URL impact:**
```
// With external_port: 30080
http://gateway:30080/core/ff-dev/entity-service/api/node/123

// With external_port: 443 (HTTPS load balancer)
http://gateway:443/core/ff-dev/entity-service/api/node/123
```

---

#### `internal_port?: number`

**Default**: `8080`  
**Used in**: Internal mode only

The port on which the entity service listens within Kubernetes.

```typescript
const client = new RemoteEntityClient(
  'http://entity-service',
  app_id,
  {
    mode: 'internal',
    internal_port: 8080  // Default, can be omitted
  }
);
```

**Standard Kubernetes service ports:**
- `8080` - HTTP (default)
- `8443` - HTTPS (if TLS configured)
- Custom ports per deployment

**When to customize:**
- Custom Kubernetes service configuration
- Multiple entity services on different ports
- Development environments with port conflicts

**URL impact:**
```
// With internal_port: 8080 (default)
http://entity-service:8080/api/node/123

// With internal_port: 9090 (custom)
http://entity-service:9090/api/node/123
```

---

#### `coreServiceRoutePrefix?: string`

**Default**: `'core'`  
**Used in**: External mode only  
**Added in**: v0.1.1

The route prefix used by Kong Gateway for core FireFoundry services.

```typescript
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: 'key',
    namespace: 'ff-dev',
    coreServiceRoutePrefix: 'core'  // Default
  }
);
```

**Purpose:**
- Groups core platform services under a common prefix
- Separates core services from other routes (e.g., agent bundles)
- Enables gateway-level policies for core services

**Common values:**
- `'core'` - Default for FireFoundry core services
- `'platform'` - Alternative grouping
- `'v1'` - Version-based routing
- `'api'` - Generic API prefix

**URL impact:**
```
// With coreServiceRoutePrefix: 'core'
http://gateway:30080/core/ff-dev/entity-service/api/node/123
                      ^^^^

// With coreServiceRoutePrefix: 'platform'
http://gateway:30080/platform/ff-dev/entity-service/api/node/123
                      ^^^^^^^^
```

**Gateway configuration:**
This should match your Kong Gateway's `coreServiceRoutePrefix` configuration. Contact your platform administrator if unsure.

---

#### `serviceName?: string`

**Default**: `'entity-service'`  
**Used in**: External mode only  
**Added in**: v0.1.1

The Kubernetes service name for the entity service.

```typescript
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: 'key',
    namespace: 'ff-dev',
    serviceName: 'entity-service'  // Default
  }
);
```

**Purpose:**
- Maps to the Kubernetes Service resource name
- Used by Kong for service discovery
- Must match the `serviceType` label in Kubernetes

**When to customize:**
- Multiple entity service instances
- Custom deployment configurations
- A/B testing different versions
- Blue-green deployments

**URL impact:**
```
// With serviceName: 'entity-service'
http://gateway:30080/core/ff-dev/entity-service/api/node/123
                                           ^^^^^^^^^^^^^^

// With serviceName: 'entity-service-v2'
http://gateway:30080/core/ff-dev/entity-service-v2/api/node/123
                                           ^^^^^^^^^^^^^^^^^
```

**Kubernetes integration:**
```yaml
# The serviceName should match this Service resource
apiVersion: v1
kind: Service
metadata:
  name: entity-service  # Must match serviceName option
  namespace: ff-control-plane
  labels:
    serviceType: entity-service  # Must also match
```

---

## Access Modes

### External Mode (Kong Gateway)

**Use case**: Applications outside the Kubernetes cluster

#### Configuration

```typescript
const client = new RemoteEntityClient(
  'http://gateway.example.com',  // Gateway hostname
  app_id,
  {
    mode: 'external',
    api_key: process.env.API_KEY,       // Required
    namespace: 'ff-dev',       // Required
    external_port: 30080,                // Optional (default: 30080)
    coreServiceRoutePrefix: 'core',      // Optional (default: 'core')
    serviceName: 'entity-service',       // Optional (default: 'entity-service')
    timeout: 60000                       // Optional (default: 200000)
  }
);
```

#### Request Flow

```
1. Client makes request
   ↓
2. Request sent to gateway:30080 with Authorization header
   ↓
3. Kong validates API key
   ↓
4. Kong routes to entity-service in specified namespace
   ↓
5. Entity service processes request
   ↓
6. Response returned through Kong
   ↓
7. Client receives response
```

#### URL Pattern

```
{base_url}:{external_port}/{coreServiceRoutePrefix}/{namespace}/{serviceName}/api/{endpoint}

Example:
http://gateway:30080/core/ff-dev/entity-service/api/node/123
```

#### Headers Added

```
Authorization: Bearer {api_key}
X-App-ID: {app_id}
X-FireFoundry-Correlation-ID: {correlation_id}
X-FireFoundry-Source-App-ID: {source_app_id}  (if available)
Content-Type: application/json
```

#### Security

- ✅ API key authentication
- ✅ TLS encryption (if configured)
- ✅ Rate limiting (if configured)
- ✅ IP allowlisting (if configured)
- ✅ Request logging and audit

#### Error Scenarios

```typescript
// Missing API key
const client = new RemoteEntityClient('http://gateway', app_id, {
  mode: 'external',
  namespace: 'ff-dev'
  // Missing api_key - throws FFError
});

// Missing namespace
const client = new RemoteEntityClient('http://gateway', app_id, {
  mode: 'external',
  api_key: 'key'
  // Missing namespace - throws FFError
});

// Invalid API key - 401 at runtime
const client = new RemoteEntityClient('http://gateway', app_id, {
  mode: 'external',
  api_key: 'invalid-key',
  namespace: 'ff-dev'
});
await client.get_node(nodeId);  // Throws FFError with 401 status
```

---

### Internal Mode (Direct Access)

**Use case**: Services within the same Kubernetes cluster

#### Configuration

```typescript
const client = new RemoteEntityClient(
  'http://entity-service',  // Kubernetes service name
  app_id,
  {
    mode: 'internal',
    internal_port: 8080,   // Optional (default: 8080)
    timeout: 30000         // Optional (default: 200000)
  }
);
```

#### Request Flow

```
1. Client makes request
   ↓
2. Request sent directly to entity-service:8080
   ↓
3. Entity service processes request (no auth check)
   ↓
4. Response returned directly
   ↓
5. Client receives response
```

#### URL Pattern

```
{base_url}:{internal_port}/api/{endpoint}

Example:
http://entity-service:8080/api/node/123
```

#### Headers Added

```
X-App-ID: {app_id}
X-FireFoundry-Correlation-ID: {correlation_id}
X-FireFoundry-Source-App-ID: {source_app_id}  (if available)
Content-Type: application/json
```

**Note**: No `Authorization` header in internal mode

#### Security

- ✅ Network policies (Kubernetes-level)
- ✅ Namespace isolation
- ✅ Service mesh policies (if configured)
- ❌ No application-level authentication
- ❌ No built-in rate limiting

#### Best Practices

```typescript
// ✅ Use Kubernetes DNS names
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal'
});

// ❌ Don't use IP addresses
const client = new RemoteEntityClient('http://10.0.0.5', app_id, {
  mode: 'internal'
});

// ✅ Use service names within same namespace
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal'
});

// ✅ Use FQDN for cross-namespace access
const client = new RemoteEntityClient(
  'http://entity-service.ff-control-plane.svc.cluster.local',
  app_id,
  { mode: 'internal' }
);
```

#### Error Scenarios

```typescript
// Providing namespace in internal mode - throws FFError
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal',
  namespace: 'ff-dev'  // Error: namespace not allowed
});

// Using API key in internal mode - ignored (no error)
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal',
  api_key: 'key'  // Ignored, but no error thrown
});
```

---

## URL Construction

### External Mode URL Builder

```typescript
// Given:
base_url = 'http://gateway.example.com'
app_id = '123e4567-e89b-12d3-a456-426614174000'
options = {
  mode: 'external',
  api_key: 'abc123',
  namespace: 'ff-dev',
  external_port: 30080,
  coreServiceRoutePrefix: 'core',
  serviceName: 'entity-service'
}

// Constructed base URL:
const baseURL = `${base_url}:${external_port}/${coreServiceRoutePrefix}/${namespace}/${serviceName}`;
// Result: http://gateway.example.com:30080/core/ff-dev/entity-service

// Full endpoint URL example:
// GET /api/node/123
// → http://gateway.example.com:30080/core/ff-dev/entity-service/api/node/123
```

### Internal Mode URL Builder

```typescript
// Given:
base_url = 'http://entity-service'
app_id = '123e4567-e89b-12d3-a456-426614174000'
options = {
  mode: 'internal',
  internal_port: 8080
}

// Constructed base URL:
const baseURL = `${base_url}:${internal_port}`;
// Result: http://entity-service:8080

// Full endpoint URL example:
// GET /api/node/123
// → http://entity-service:8080/api/node/123
```

### Common Endpoint Patterns

| Operation | Method | Path | Example |
|-----------|--------|------|---------|
| Get node | GET | `/api/node/:id` | `/api/node/123` |
| Get nodes (batch) | POST | `/api/nodes/batch` | `/api/nodes/batch` |
| Create node | POST | `/api/node` | `/api/node` |
| Update node data | PATCH | `/api/node/:id/data` | `/api/node/123/data` |
| Get node edges | GET | `/api/node/:id/edges/from` | `/api/node/123/edges/from?edge_types=connects` |
| Search nodes | POST | `/api/search/nodes` | `/api/search/nodes` |
| Vector search | POST | `/api/vector/search` | `/api/vector/search` |

---

## Authentication & Security

### API Key Management

#### Obtaining an API Key

```bash
# Contact your FireFoundry administrator to generate an API key
# Keys are managed through the Management Console
```

#### Storing API Keys

```typescript
// ✅ Use environment variables
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: process.env.FIREFOUNDRY_API_KEY,
    namespace: 'ff-dev'
  }
);

// ✅ Use secret management systems
import { getSecret } from './secrets';
const apiKey = await getSecret('firefoundry-api-key');
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: apiKey,
    namespace: 'ff-dev'
  }
);

// ❌ Never hardcode API keys
const client = new RemoteEntityClient(
  'http://gateway',
  app_id,
  {
    mode: 'external',
    api_key: 'sk-abc123xyz',  // Don't do this!
    namespace: 'ff-dev'
  }
);
```

### App ID Scoping

Every request includes an `app_id` that scopes entity operations:

```typescript
// All operations are scoped to this app_id
const client = new RemoteEntityClient(
  'http://entity-service',
  '123e4567-e89b-12d3-a456-426614174000',  // app_id
  { mode: 'internal' }
);

// This search only returns nodes where app_id matches
const nodes = await client.search_nodes_scoped(
  { status: 'active' },
  { created: 'desc' }
);
```

**How it works:**
1. Client sends `X-App-ID` header on every request
2. Server middleware extracts it to `req.appId`
3. Database queries filter by `app_id`
4. Ensures data isolation between applications

**Security implications:**
- Apps can only access their own entities
- Cross-app access requires explicit API design
- Provides multi-tenancy within single database

### Network Security

#### External Mode
- Traffic flows through Kong Gateway
- Can enforce TLS/HTTPS
- Supports IP allowlisting
- Can add WAF protection
- Enables rate limiting per API key

#### Internal Mode
- Relies on Kubernetes network policies
- No encryption by default (cluster-internal)
- Can use service mesh (Istio, Linkerd) for mTLS
- Namespace-based isolation

---

## Request Flow

### Request Lifecycle

```
┌──────────────┐
│   Client     │
│   Code       │
└──────┬───────┘
       │
       │ 1. Method Call
       │    client.get_node(id)
       ▼
┌──────────────────────┐
│ Request Interceptor  │
│ - Get/gen correlation│
│ - Add X-App-ID       │
│ - Add correlation ID │
│ - Add source app ID  │
│ - Log request        │
└──────┬───────────────┘
       │
       │ 2. HTTP Request
       │    GET /api/node/123
       │    Headers: X-App-ID, Authorization, etc.
       ▼
┌──────────────────────┐
│  Kong Gateway        │
│  (External Mode)     │
│  - Validate API key  │
│  - Route to service  │
└──────┬───────────────┘
       │
       │ 3. Forwarded Request
       ▼
┌──────────────────────┐
│  Entity Service      │
│  - Extract X-App-ID  │
│  - Process request   │
│  - Query database    │
└──────┬───────────────┘
       │
       │ 4. Response
       ▼
┌──────────────────────┐
│ Response Interceptor │
│ - Log response       │
│ - Transform errors   │
└──────┬───────────────┘
       │
       │ 5. Return Value
       ▼
┌──────────────┐
│   Client     │
│   Code       │
└──────────────┘
```

### Correlation Tracking

The client automatically manages correlation IDs for distributed tracing:

```typescript
import { FFAsyncLocalStorage } from '@firebrandanalytics/shared-utils';

// Correlation ID is automatically generated or propagated
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal'
});

// If running in an async context with existing correlation:
await FFAsyncLocalStorage.run({ _correlation_id: 'existing-id' }, async () => {
  // This request will use 'existing-id'
  const node = await client.get_node(nodeId);
});

// If no context exists, a new correlation ID is generated
const node = await client.get_node(nodeId);
// Generates: X-FireFoundry-Correlation-ID: <new-uuid>
```

**Correlation headers added:**
- `X-FireFoundry-Correlation-ID`: Request correlation ID
- `X-FireFoundry-Source-App-ID`: Source application ID (if available)

**Benefits:**
- Trace requests across services
- Debug distributed workflows
- Analyze performance bottlenecks
- Aggregate logs by operation

---

## API Reference

### Type Definitions

Before diving into specific methods, here are the core types used throughout the API:

#### UUID
```typescript
type UUID = string;  // UUID v4 format
```

#### JSONObject and JSONValue
```typescript
type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };
type JSONObject = { [key: string]: JSONValue };
```

#### EntityNodeDTO
```typescript
interface EntityNodeDTO {
  id: UUID;
  app_id: UUID;
  name: string;
  general_type_name: string;
  general_type_id: UUID | null;
  specific_type_name: string;
  specific_type_id: UUID | null;
  schema?: JSONObject;
  grpc_proto?: string;
  openapi_spec?: JSONObject;
  data?: JSONObject;
  interface?: 'None' | 'gRPC' | 'HTTP' | 'WebSocket';
  status?: EntityNodeStatus;
  archive: boolean;
  created: string;  // ISO 8601 timestamp
  modified: string; // ISO 8601 timestamp
  metadata?: JSONObject;
}
```

#### EntityNodeStatus
```typescript
type EntityNodeStatus = 
  | 'Pending'
  | 'InProgress'
  | 'Completed'
  | 'Failed'
  | 'Cancelled'
  | 'Paused';
```

#### EntityEdgeDTO
```typescript
interface EntityEdgeDTO {
  id: UUID;
  app_id: UUID;
  from_node_id: UUID;
  from_node_type: string;
  to_node_id: UUID;
  to_node_type: string;
  general_type_name: string;
  general_type_id: UUID | null;
  specific_type_name: string;
  specific_type_id: UUID | null;
  data: JSONObject;
  position: number;  // Sequential position within edge type from same node
  archive: boolean;
  created: string;  // ISO 8601 timestamp
  modified: string; // ISO 8601 timestamp
}
```

#### Conditions (Search Filtering)
```typescript
type Conditions = {
  [field: string]: 
    | any                          // Exact match: { status: 'active' }
    | { $eq: any }                 // Equal: { status: { $eq: 'active' } }
    | { $ne: any }                 // Not equal: { status: { $ne: 'archived' } }
    | { $gt: any }                 // Greater than: { created: { $gt: '2024-01-01' } }
    | { $gte: any }                // Greater than or equal
    | { $lt: any }                 // Less than
    | { $lte: any }                // Less than or equal
    | { $in: any[] }               // In array: { status: { $in: ['active', 'pending'] } }
    | { $nin: any[] }              // Not in array
    | { $like: string }            // SQL LIKE pattern: { name: { $like: '%test%' } }
    | { $ilike: string }           // Case-insensitive LIKE
    | { $contains: any }           // JSONB contains (for data field)
    | { $contained_by: any }       // JSONB contained by
    | { '@>': any }                // JSONB contains operator
    | { '<@': any };               // JSONB contained by operator
};

// Logical operators
type Conditions = Conditions | {
  $and?: Conditions[];
  $or?: Conditions[];
  $not?: Conditions;
};
```

**Examples:**
```typescript
// Simple exact match
{ status: 'active' }

// Multiple conditions (implicit AND)
{ status: 'active', archive: false }

// Greater than timestamp
{ created: { $gt: '2024-01-01T00:00:00Z' } }

// IN array
{ status: { $in: ['Pending', 'InProgress'] } }

// Pattern matching
{ name: { $like: '%report%' } }

// JSONB path queries (on data field)
{ 'data->type': 'document' }
{ 'data->>status': 'published' }

// JSONB contains
{ data: { '@>': { type: 'document', published: true } } }

// Complex logical operators
{
  $or: [
    { status: 'active' },
    { $and: [{ status: 'pending' }, { priority: 'high' }] }
  ]
}
```

**Searchable Fields:**
All top-level fields on EntityNodeDTO and EntityEdgeDTO are searchable:
- `id`, `app_id`, `name`, `general_type_name`, `specific_type_name`
- `status`, `archive`, `created`, `modified`
- `interface` (for nodes)
- `from_node_id`, `to_node_id`, `position` (for edges)
- JSONB fields: `data`, `schema`, `metadata` (use JSONB operators)

#### OrderBy
```typescript
type OrderBy = {
  [field: string]: 'asc' | 'desc' | 'ASC' | 'DESC';
};
```

**Examples:**
```typescript
// Single field
{ created: 'desc' }

// Multiple fields (order matters)
{ status: 'asc', created: 'desc' }

// JSONB fields
{ 'data->priority': 'desc', modified: 'desc' }
```

**Orderable Fields:**
Same as searchable fields. Common patterns:
- `created: 'desc'` - Newest first
- `modified: 'desc'` - Recently updated first
- `name: 'asc'` - Alphabetical
- `position: 'asc'` - Sequential order (for edges)

#### Pagination
```typescript
type Pagination = {
  page: number;     // Page number (1-indexed, first page = 1)
  size: number;     // Number of results per page
};
```

**Examples:**
```typescript
// First 20 results (page 1)
{ page: 1, size: 20 }

// Second page (results 21-40)
{ page: 2, size: 20 }

// Large result set (first 100)
{ page: 1, size: 100 }

// Converting from offset/limit to page/size:
const page = Math.floor(offset / limit) + 1;  // +1 because pages are 1-indexed
const size = limit;

// Converting from page/size back to offset/limit:
const offset = (page - 1) * size;
const limit = size;
```

**Pagination Notes:**
- `page` is **1-indexed** (first page = 1, not 0)
- Server calculates offset as: `(page - 1) * size`
- Default size is typically 10 if not specified
- Total count is returned separately in search results
- For large datasets, use page-based pagination in chunks

---

### Node Operations

#### get_node

Retrieves one or more entity nodes by ID(s).

**Signatures:**
```typescript
get_node(id: UUID): Promise<EntityNodeDTO | undefined>
get_node(ids: UUID[]): Promise<(EntityNodeDTO | undefined)[]>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Single node ID to retrieve |
| `ids` | `UUID[]` | Yes | Array of node IDs to retrieve |

**Returns:**

- **Single ID**: `EntityNodeDTO | undefined`
  - Returns node object if found
  - Returns `undefined` if not found (404)
  
- **Array of IDs**: `(EntityNodeDTO | undefined)[]`
  - Returns array matching input order
  - Missing nodes are `undefined` in result array
  - Never throws on 404, omits missing nodes

**Example:**
```typescript
// Single node
const node = await client.get_node('550e8400-e29b-41d4-a716-446655440000');
if (node) {
  console.log('Node name:', node.name);
}

// Batch retrieval
const ids = ['id1', 'id2', 'id3'];
const nodes = await client.get_node(ids);
// nodes = [NodeDTO, undefined, NodeDTO] if id2 doesn't exist
```

**Error Handling:**
- Returns `undefined` for 404 (single node)
- Returns empty array `[]` if all nodes missing (batch)
- Throws `FFError` for other errors (network, server errors)

---

#### get_node_by_name

Retrieves a node by its unique name within an app scope.

**Signature:**
```typescript
get_node_by_name(name: string): Promise<EntityNodeDTO>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `name` | `string` | Yes | Unique node name within the app |

**Returns:**

`EntityNodeDTO` - The node with matching name

**Constraints:**
- Searches within `app_id` scope (set in constructor)
- Names are unique per app_id
- Query: `WHERE app_id = $app_id AND name = $name`

**Example:**
```typescript
const node = await client.get_node_by_name('my-workflow-v1');
console.log('Node ID:', node.id);
```

**Error Handling:**
- Throws `FFError` if node not found (404)
- Throws `FFError` for other errors

---

#### create_node

Creates a new entity node (class or instance).

**Signatures:**
```typescript
create_node(node: UnsavedEntityClassNodeDTO): Promise<EntityClassNodeDTO>
create_node<D extends JSONObject>(
  node: UnsavedEntityInstanceNodeDTO<D>
): Promise<EntityInstanceNodeDTO<D>>
```

**Parameters:**

**UnsavedEntityClassNodeDTO:**
```typescript
{
  app_id: UUID;                    // Required: Application scope
  name: string;                    // Required: Unique within app_id
  general_type_name: string;       // Required: Broad category (e.g., 'Entity')
  specific_type_name: string;      // Required: Specific type (e.g., 'Agent')
  schema?: JSONObject;             // Optional: JSON schema definition
  grpc_proto?: string;             // Optional: gRPC proto definition
  openapi_spec?: JSONObject;       // Optional: OpenAPI specification
  interface?: 'None' | 'gRPC' | 'HTTP' | 'WebSocket';  // Default: 'None'
  id?: UUID;                       // Optional: Custom ID (generated if omitted)
}
```

**UnsavedEntityInstanceNodeDTO<D>:**
```typescript
{
  app_id: UUID;                    // Required
  name: string;                    // Required: Unique within app_id
  general_type_name: string;       // Required
  specific_type_name: string;      // Required (usually references a class)
  data: D;                         // Required: Instance data payload
  status?: EntityNodeStatus;       // Optional: Default 'Pending'
  interface?: 'None' | 'gRPC' | 'HTTP' | 'WebSocket';  // Default: 'None'
  metadata?: JSONObject;           // Optional: Additional metadata
  id?: UUID;                       // Optional: Custom ID
}
```

**Returns:**

- `EntityClassNodeDTO` - Created class node with generated `id`
- `EntityInstanceNodeDTO<D>` - Created instance node with generated `id`

**Behavior:**
- If `id` provided: Uses `INSERT ... ON CONFLICT UPDATE` (upsert)
- If `name` exists: Performs `ON CONFLICT (app_id, name) DO UPDATE`
- Automatically looks up `general_type_id` and `specific_type_id` from names
- Sets timestamps: `created`, `modified`

**Example:**
```typescript
// Create class node
const agentClass = await client.create_node({
  app_id: myAppId,
  name: 'EmailAgent',
  general_type_name: 'Agent',
  specific_type_name: 'EmailAgent',
  schema: { /* JSON schema */ }
});

// Create instance node
const workflowInstance = await client.create_node({
  app_id: myAppId,
  name: 'daily-report-workflow-001',
  general_type_name: 'Workflow',
  specific_type_name: 'ReportWorkflow',
  data: {
    schedule: 'daily',
    recipients: ['user@example.com']
  },
  status: 'Pending'
});
```

**Error Handling:**
- Throws `FFError` if required fields missing
- Throws `FFError` if type names don't exist in database
- Throws `FFError` on database constraint violations

---

#### create_node_if_not_exists

Atomically creates a node only if one with the same `app_id` and `name` doesn't exist.

**Signature:**
```typescript
create_node_if_not_exists<D extends JSONObject>(
  node: UnsavedEntityClassNodeDTO | UnsavedEntityInstanceNodeDTO<D>
): Promise<EntityClassNodeDTO | EntityInstanceNodeDTO<D> | null>
```

**Parameters:**

Same as `create_node` (see above)

**Returns:**

- `EntityNodeDTO` - Newly created node
- `null` - If node with same `app_id` + `name` already exists

**Behavior:**
- Uses `INSERT ... ON CONFLICT (app_id, name) DO NOTHING`
- Atomic operation (safe for concurrent requests)
- Useful for idempotent initialization

**Example:**
```typescript
const node = await client.create_node_if_not_exists({
  app_id: myAppId,
  name: 'singleton-service',
  general_type_name: 'Service',
  specific_type_name: 'EmailService',
  data: { initialized: true }
});

if (node === null) {
  console.log('Node already exists');
  // Fetch existing node
  const existing = await client.get_node_by_name('singleton-service');
} else {
  console.log('Created new node:', node.id);
}
```

**Error Handling:**
- Returns `null` on conflict (409)
- Throws `FFError` for other errors

---

#### archive_node

Archives or unarchives a node (soft delete).

**Signature:**
```typescript
archive_node(id: UUID, archived?: boolean): Promise<EntityNodeDTO>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `id` | `UUID` | Yes | - | Node ID to archive |
| `archived` | `boolean` | No | `true` | Archive state |

**Returns:**

`EntityNodeDTO` - Updated node with `archive` field set

**Behavior:**
- Sets `archive` field to `true` (archived) or `false` (active)
- Does not delete node from database
- Archived nodes typically excluded from searches (application logic)
- Updates `modified` timestamp

**Example:**
```typescript
// Archive a node
const archived = await client.archive_node(nodeId);
console.log('Archived:', archived.archive); // true

// Unarchive a node
const restored = await client.archive_node(nodeId, false);
console.log('Archived:', restored.archive); // false
```

**Error Handling:**
- Throws `FFError` if node not found (404)
- Throws `FFError` for other errors

---

#### update_node_data

Updates the `data` field of a node (full or partial update).

**Signatures:**
```typescript
update_node_data(id: UUID, data: JSONObject): Promise<EntityNodeDTO>
update_node_data(
  id: UUID,
  value: JSONValue,
  path: string[],
  appendToArray?: boolean
): Promise<EntityNodeDTO>
```

**Parameters:**

**Full Update:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Node ID to update |
| `data` | `JSONObject` | Yes | New data object (replaces existing) |

**Partial Update (Path-based):**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `id` | `UUID` | Yes | - | Node ID to update |
| `value` | `JSONValue` | Yes | - | Value to set at path |
| `path` | `string[]` | Yes | - | JSON path to target field |
| `appendToArray` | `boolean` | No | `false` | Append to array instead of replace |

**Returns:**

`EntityNodeDTO` - Updated node with modified `data` field

**Behavior:**

**Full Update:**
- Replaces entire `data` object
- Previous data is lost

**Partial Update:**
- Uses PostgreSQL `jsonb_set` function
- Creates nested structure if path doesn't exist
- Preserves other fields in `data` object
- If `appendToArray=true`, appends to array at path (uses `||` operator)

**Path Syntax:**
- Array of strings representing nested keys
- Example: `['user', 'address', 'city']` → `data.user.address.city`
- Handles special characters and spaces in keys

**Examples:**
```typescript
// Full data replacement
await client.update_node_data(nodeId, {
  status: 'active',
  config: { enabled: true }
});

// Update nested field
await client.update_node_data(
  nodeId,
  'published',
  ['status']
);

// Update deeply nested field
await client.update_node_data(
  nodeId,
  'San Francisco',
  ['user', 'address', 'city']
);

// Append to array
await client.update_node_data(
  nodeId,
  { timestamp: Date.now(), action: 'viewed' },
  ['audit', 'events'],
  true  // Append to array
);

// Result: data.audit.events = [...existing, newEvent]
```

**Error Handling:**
- Throws `FFError` if node not found (404)
- Throws `FFError` if path invalid or type mismatch
- Throws `FFError` for other errors

---

#### update_node_status

Updates the status field of a node.

**Signature:**
```typescript
update_node_status(id: UUID, status: EntityNodeStatus): Promise<EntityNodeDTO>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Node ID to update |
| `status` | `EntityNodeStatus` | Yes | New status value |

**Valid Status Values:**
- `'Pending'` - Awaiting processing
- `'InProgress'` - Currently processing
- `'Completed'` - Successfully finished
- `'Failed'` - Encountered error
- `'Cancelled'` - Manually cancelled
- `'Paused'` - Temporarily paused

**Returns:**

`EntityNodeDTO` - Updated node with new status

**Example:**
```typescript
await client.update_node_status(runnableId, 'InProgress');
// ... do work ...
await client.update_node_status(runnableId, 'Completed');
```

**Error Handling:**
- Throws `FFError` if node not found (404)
- Throws `FFError` if status value invalid
- Throws `FFError` for other errors

---

#### update_node_status_conditional

Atomically updates node status only if current status matches expected value.

**Signature:**
```typescript
update_node_status_conditional(
  nodeId: UUID,
  newStatus: EntityNodeStatus,
  requiredCurrentStatus: EntityNodeStatus
): Promise<number>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `nodeId` | `UUID` | Yes | Node ID to update |
| `newStatus` | `EntityNodeStatus` | Yes | Status to set if condition met |
| `requiredCurrentStatus` | `EntityNodeStatus` | Yes | Required current status |

**Returns:**

`number` - Count of rows updated (0 or 1)
- `1` - Status was updated (condition met)
- `0` - Status not updated (condition not met)

**Behavior:**
- Uses SQL: `UPDATE ... WHERE id = $1 AND status = $2`
- Atomic operation (safe for concurrent access)
- Scoped to `app_id` from client constructor
- Common pattern for job queues and state machines

**Use Cases:**
- **Job Claiming**: Update from 'Pending' to 'InProgress' atomically
- **State Transitions**: Ensure valid state machine transitions
- **Conflict Prevention**: Prevent multiple workers claiming same job

**Example:**
```typescript
// Try to claim a job
const claimed = await client.update_node_status_conditional(
  jobId,
  'InProgress',      // New status
  'Pending'          // Required current status
);

if (claimed === 1) {
  console.log('Job claimed successfully');
  // Process the job
} else {
  console.log('Job already claimed by another worker');
}
```

**Example: Job Queue Pattern**
```typescript
async function claimNextJob(
  client: RemoteEntityClient,
  jobIds: UUID[]
): Promise<UUID | null> {
  for (const jobId of jobIds) {
    const claimed = await client.update_node_status_conditional(
      jobId,
      'InProgress',
      'Pending'
    );
    
    if (claimed === 1) {
      return jobId;  // Successfully claimed
    }
  }
  
  return null;  // No jobs available
}
```

**Error Handling:**
- Returns `0` if condition not met (not an error)
- Throws `FFError` if node not found
- Throws `FFError` for other errors

---

### Edge Operations

#### get_edge

Retrieves one or more entity edges by ID(s).

**Signatures:**
```typescript
get_edge(id: UUID): Promise<EntityEdgeDTO | undefined>
get_edge(ids: UUID[]): Promise<(EntityEdgeDTO | undefined)[]>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Single edge ID |
| `ids` | `UUID[]` | Yes | Array of edge IDs |

**Returns:**

- **Single ID**: `EntityEdgeDTO | undefined`
- **Array of IDs**: `(EntityEdgeDTO | undefined)[]`

Same behavior as `get_node` - returns `undefined` for missing edges.

**Example:**
```typescript
const edge = await client.get_edge(edgeId);
if (edge) {
  console.log('Edge connects:', edge.from_node_id, '→', edge.to_node_id);
}
```

---

#### create_edge

Creates a new edge between two nodes with manual position management.

**Signature:**
```typescript
create_edge(edge: UnsavedEntityEdgeDTO): Promise<EntityEdgeDTO>
```

**Parameters:**

**UnsavedEntityEdgeDTO:**
```typescript
{
  app_id: UUID;                  // Required: Application scope
  from_node_id: UUID;            // Required: Source node
  from_node_type: string;        // Required: Source node type name
  to_node_id: UUID;              // Required: Target node
  to_node_type: string;          // Required: Target node type name
  general_type_name: string;     // Required: Edge category
  specific_type_name: string;    // Required: Specific edge type
  data?: JSONObject;             // Optional: Edge data payload
}
```

**Returns:**

`EntityEdgeDTO` - Created edge with generated `id` and calculated `position`

**Behavior:**
- Automatically calculates next sequential `position` for the edge type from the source node
- Uses database lock to prevent race conditions: `FOR NO KEY UPDATE`
- Position is scoped to: `(from_node_id, specific_type_name)`
- Sets timestamps: `created`, `modified`

**Position Calculation:**
```sql
-- Finds max position for this from_node_id + specific_type_name
-- and adds 1
COALESCE(MAX(position), 0) + 1
```

**Example:**
```typescript
const edge = await client.create_edge({
  app_id: myAppId,
  from_node_id: workflowId,
  from_node_type: 'Workflow',
  to_node_id: agentId,
  to_node_type: 'Agent',
  general_type_name: 'Connection',
  specific_type_name: 'contains',
  data: { order: 1, required: true }
});

console.log('Edge position:', edge.position); // 1, 2, 3, etc.
```

**Error Handling:**
- Throws `FFError` if from_node or to_node doesn't exist
- Throws `FFError` if type names invalid
- Throws `FFError` on database constraint violations

---

#### create_edge_udf

Creates an edge using a User-Defined Function with automatic position increment.

**Signature:**
```typescript
create_edge_udf(edge: UnsavedEntityEdgeDTO): Promise<EntityEdgeDTO>
```

**Parameters:**

Same as `create_edge` (see above)

**Returns:**

`EntityEdgeDTO` - Created edge with generated `id` and position

**Behavior:**
- Calls PostgreSQL function: `entity.create_edge_with_incrementing_pos()`
- Automatically handles position calculation in database
- Equivalent to `create_edge` but uses UDF for consistency

**When to use:**
- Use `create_edge_udf` for compatibility with database-side logic
- Use `create_edge` for standard operations
- Functionally equivalent in most cases

**Example:**
```typescript
const edge = await client.create_edge_udf({
  app_id: myAppId,
  from_node_id: parentId,
  from_node_type: 'Folder',
  to_node_id: childId,
  to_node_type: 'Document',
  general_type_name: 'Hierarchy',
  specific_type_name: 'contains',
  data: {}
});
```

---

#### archive_edge

Archives or unarchives an edge (soft delete).

**Signature:**
```typescript
archive_edge(id: UUID, archived?: boolean): Promise<EntityEdgeDTO>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `id` | `UUID` | Yes | - | Edge ID to archive |
| `archived` | `boolean` | No | `true` | Archive state |

**Returns:**

`EntityEdgeDTO` - Updated edge with `archive` field set

Same behavior as `archive_node` but for edges.

**Example:**
```typescript
await client.archive_edge(edgeId);        // Archive
await client.archive_edge(edgeId, false); // Unarchive
```

---

#### update_edge_data

Updates the `data` field of an edge (full or partial).

**Signatures:**
```typescript
update_edge_data(id: UUID, data: JSONObject): Promise<EntityEdgeDTO>
update_edge_data(
  id: UUID,
  value: JSONValue,
  path: string[]
): Promise<EntityEdgeDTO>
```

**Parameters:**

Same as `update_node_data` but for edges (see above for details)

**Note:** Edge data updates do NOT support `appendToArray` parameter.

**Example:**
```typescript
// Full replacement
await client.update_edge_data(edgeId, {
  weight: 0.8,
  label: 'primary'
});

// Partial update
await client.update_edge_data(
  edgeId,
  0.9,
  ['weight']
);
```

---

### Relationship Queries

#### get_node_edges_from

Retrieves all outgoing edges from a node.

**Signature:**
```typescript
get_node_edges_from(
  id: UUID,
  edge_types?: string[]
): Promise<{ [key: string]: EntityEdgeDTO[] }>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Source node ID |
| `edge_types` | `string[]` | No | Filter by specific edge type names |

**Returns:**

`{ [edgeType: string]: EntityEdgeDTO[] }`

Object mapping edge type names to arrays of edges, grouped and sorted by:
1. `specific_type_name` (grouping)
2. `position` (ordering within group)

**Behavior:**
- Returns edges where `from_node_id = id`
- If `edge_types` provided: filters by `specific_type_name IN (edge_types)`
- Groups edges by `specific_type_name`
- Sorts by `position` within each group
- Scoped to `app_id` from client if available

**Example:**
```typescript
// Get all outgoing edges
const edges = await client.get_node_edges_from(nodeId);
// Result: {
//   'contains': [edge1, edge2, edge3],
//   'depends_on': [edge4, edge5]
// }

// Get specific edge types only
const specificEdges = await client.get_node_edges_from(nodeId, [
  'contains',
  'references'
]);
// Result: {
//   'contains': [edge1, edge2],
//   'references': [edge3]
// }

// Access edges by type
const containsEdges = edges['contains'] || [];
for (const edge of containsEdges) {
  console.log('Connected to:', edge.to_node_id);
}
```

---

#### get_node_edges_to

Retrieves all incoming edges to a node.

**Signature:**
```typescript
get_node_edges_to(
  id: UUID,
  edge_types?: string[]
): Promise<{ [key: string]: EntityEdgeDTO[] }>
```

**Parameters:**

Same as `get_node_edges_from`

**Returns:**

Same structure as `get_node_edges_from`

**Behavior:**
- Returns edges where `to_node_id = id`
- Otherwise identical to `get_node_edges_from`

**Example:**
```typescript
// Get all incoming edges
const incomingEdges = await client.get_node_edges_to(nodeId);

// Find all parents via 'contains' relationship
const parents = incomingEdges['contains'] || [];
```

---

#### get_node_edges

Retrieves both outgoing and incoming edges for a node.

**Signature:**
```typescript
get_node_edges(
  id: UUID,
  edge_types?: string[]
): Promise<{
  edges_from: { [key: string]: EntityEdgeDTO[] };
  edges_to: { [key: string]: EntityEdgeDTO[] };
}>
```

**Parameters:**

Same as `get_node_edges_from`

**Returns:**

```typescript
{
  edges_from: { [edgeType: string]: EntityEdgeDTO[] };  // Outgoing
  edges_to: { [edgeType: string]: EntityEdgeDTO[] };    // Incoming
}
```

**Behavior:**
- Parallel execution of `get_node_edges_from` and `get_node_edges_to`
- More efficient than calling both separately

**Example:**
```typescript
const { edges_from, edges_to } = await client.get_node_edges(nodeId, [
  'contains',
  'depends_on'
]);

console.log('Children:', edges_from['contains']?.length);
console.log('Parents:', edges_to['contains']?.length);
console.log('Dependencies:', edges_from['depends_on']?.length);
console.log('Dependents:', edges_to['depends_on']?.length);
```

---

#### get_entity_with_edges_from

Retrieves a node with its outgoing edges embedded.

**Signature:**
```typescript
get_entity_with_edges_from(
  id: UUID,
  edge_types?: string[]
): Promise<EntityNodeWithEdgesFromDTO | undefined>
```

**Parameters:**

Same as `get_node_edges_from`

**Returns:**

```typescript
EntityNodeWithEdgesFromDTO | undefined

// Structure:
{
  ...EntityNodeDTO,                                     // All node fields
  edges_from: { [edgeType: string]: EntityEdgeDTO[] }  // Outgoing edges
}
```

**Behavior:**
- Combines `get_node` and `get_node_edges_from`
- Returns `undefined` if node doesn't exist (404)
- Useful for fetching node + relationships in one call

**Example:**
```typescript
const nodeWithEdges = await client.get_entity_with_edges_from(nodeId, [
  'contains'
]);

if (nodeWithEdges) {
  console.log('Node:', nodeWithEdges.name);
  console.log('Children:', nodeWithEdges.edges_from['contains']?.length);
}
```

---

#### get_entity_with_edges_to

Retrieves a node with its incoming edges embedded.

**Signature:**
```typescript
get_entity_with_edges_to(
  id: UUID,
  edge_types?: string[]
): Promise<EntityNodeWithEdgesToDTO | undefined>
```

**Parameters:**

Same as `get_node_edges_from`

**Returns:**

```typescript
{
  ...EntityNodeDTO,
  edges_to: { [edgeType: string]: EntityEdgeDTO[] }  // Incoming edges
}
```

Mirrors `get_entity_with_edges_from` but for incoming edges.

---

#### get_entity_with_edges

Retrieves a node with both outgoing and incoming edges embedded.

**Signature:**
```typescript
get_entity_with_edges(
  id: UUID,
  edge_types?: string[]
): Promise<EntityNodeWithEdgesDTO | undefined>
```

**Parameters:**

Same as `get_node_edges_from`

**Returns:**

```typescript
{
  ...EntityNodeDTO,
  edges_from: { [edgeType: string]: EntityEdgeDTO[] },  // Outgoing
  edges_to: { [edgeType: string]: EntityEdgeDTO[] }     // Incoming
}
```

**Example:**
```typescript
const fullNode = await client.get_entity_with_edges(nodeId);

if (fullNode) {
  // Access node properties
  console.log('Node:', fullNode.name, fullNode.status);
  
  // Access relationships
  const children = fullNode.edges_from['contains'] || [];
  const parents = fullNode.edges_to['contains'] || [];
  
  console.log(`${children.length} children, ${parents.length} parents`);
}
```

---

### Graph Traversal

#### get_connected_node_ids

Retrieves IDs of nodes connected via specified edge type(s).

**Signatures:**
```typescript
get_connected_node_ids(
  id: UUID,
  edge_type: string
): Promise<UUID[]>

get_connected_node_ids(
  id: UUID,
  edge_types: string[]
): Promise<{ [key: string]: UUID[] }>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Source node ID |
| `edge_type` | `string` | Yes | Single edge type name |
| `edge_types` | `string[]` | Yes | Multiple edge type names |

**Returns:**

- **Single type**: `UUID[]` - Array of connected node IDs
- **Multiple types**: `{ [edgeType: string]: UUID[] }` - Mapped by edge type

**Behavior:**
- Returns `to_node_id` for each outgoing edge of specified type(s)
- Ordered by edge `position`
- More efficient than `get_connected_nodes` if you only need IDs

**Example:**
```typescript
// Single edge type
const childIds = await client.get_connected_node_ids(folderId, 'contains');
// ['id1', 'id2', 'id3']

// Multiple edge types
const connections = await client.get_connected_node_ids(nodeId, [
  'contains',
  'references'
]);
// {
//   'contains': ['id1', 'id2'],
//   'references': ['id3', 'id4']
// }
```

---

#### get_connected_nodes

Retrieves full node objects for connected nodes via specified edge type(s).

**Signatures:**
```typescript
get_connected_nodes(
  id: UUID,
  edge_type: string
): Promise<EntityNodeDTO[]>

get_connected_nodes(
  id: UUID,
  edge_types: string[]
): Promise<{ [key: string]: EntityNodeDTO[] }>
```

**Parameters:**

Same as `get_connected_node_ids`

**Returns:**

- **Single type**: `EntityNodeDTO[]` - Array of connected nodes
- **Multiple types**: `{ [edgeType: string]: EntityNodeDTO[] }` - Mapped by edge type

**Behavior:**
- Equivalent to `get_connected_node_ids` followed by `get_node(ids)`
- Returns full node objects instead of just IDs
- Missing nodes are filtered out (shouldn't happen with FK constraints)

**Example:**
```typescript
// Get all children nodes
const children = await client.get_connected_nodes(parentId, 'contains');

for (const child of children) {
  console.log(`Child: ${child.name} (${child.status})`);
}

// Get multiple relationship types
const related = await client.get_connected_nodes(nodeId, [
  'depends_on',
  'references'
]);

console.log('Dependencies:', related['depends_on'].map(n => n.name));
console.log('References:', related['references'].map(n => n.name));
```

---

#### get_connected_nodes_udf

Performs deep recursive graph traversal using a database UDF.

**Signature:**
```typescript
get_connected_nodes_udf(
  id: UUID,
  edge_type: string,
  max_depth?: number
): Promise<JSONObject>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `id` | `UUID` | Yes | - | Starting node ID |
| `edge_type` | `string` | Yes | - | Edge type to follow |
| `max_depth` | `number` | No | `1` | Maximum traversal depth |

**Returns:**

`JSONObject` - Hierarchical tree structure

**Structure (recursive):**
```typescript
{
  id: UUID;
  name: string;
  data: JSONObject;
  input?: JSONObject;   // From node_io table
  output?: JSONObject;  // From node_io table
  children: Array<{    // Recursively nested
    id: UUID;
    name: string;
    data: JSONObject;
    input?: JSONObject;
    output?: JSONObject;
    children: [...];
  }>;
}
```

**Behavior:**
- Uses PostgreSQL recursive CTE via `entity.get_connected_nodes_with_io()` UDF
- Traverses graph depth-first
- Includes node I/O data from `entity.node_io` table
- More efficient than multiple client-side requests for deep hierarchies

**Example:**
```typescript
// Build entire project tree up to 3 levels deep
const projectTree = await client.get_connected_nodes_udf(
  projectRootId,
  'contains',
  3
);

console.log('Root:', projectTree.name);
console.log('Children:', projectTree.children.length);

// Traverse tree
function printTree(node: any, indent = 0) {
  console.log('  '.repeat(indent) + node.name);
  for (const child of node.children || []) {
    printTree(child, indent + 1);
  }
}

printTree(projectTree);
```

**Performance Considerations:**
- `max_depth=1`: Fast, equivalent to one-level traversal
- `max_depth=5-10`: Moderate, suitable for most hierarchies
- `max_depth>10`: Slow, consider pagination or alternative approaches
- Returns entire subtree in one query (can be large)

---

#### get_reverse_connected_nodes

Traverses graph backwards from multiple starting nodes.

**Signature:**
```typescript
get_reverse_connected_nodes(
  ids: UUID[],
  edge_type: string,
  max_depth?: number
): Promise<JSONObject>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `ids` | `UUID[]` | Yes | - | Starting node IDs (multiple) |
| `edge_type` | `string` | Yes | - | Edge type to follow backwards |
| `max_depth` | `number` | No | `1` | Maximum traversal depth |

**Returns:**

`JSONObject` - Hierarchical structure (format varies by UDF implementation)

**Behavior:**
- Follows edges backwards (`to_node_id` → `from_node_id`)
- Useful for finding all ancestors or dependencies
- Can start from multiple nodes simultaneously

**Use Cases:**
- Find all parent folders of multiple documents
- Find all dependencies for a set of modules
- Build reverse dependency tree

**Example:**
```typescript
// Find all folders containing these documents
const documents = ['doc1-id', 'doc2-id', 'doc3-id'];
const containers = await client.get_reverse_connected_nodes(
  documents,
  'contains',  // Follow 'contains' edges backwards
  5            // Up to 5 levels up
);

// Result shows folder hierarchy containing all documents
```

---

#### find_connected_nodes_by_jsonpath

Advanced filtered graph traversal with JSONPath queries, pagination, and sorting.

**Signature:**
```typescript
find_connected_nodes_by_jsonpath(
  node_id: UUID,
  edge_type_name: string,
  options?: FindConnectedNodesJsonPathArgs
): Promise<ConnectedNodesFiltered>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `node_id` | `UUID` | Yes | - | Starting node ID |
| `edge_type_name` | `string` | Yes | - | Edge type to follow |
| `options` | `FindConnectedNodesJsonPathArgs` | No | `{}` | Filter and pagination options |

**FindConnectedNodesJsonPathArgs:**
```typescript
{
  edge_jsonpath_filter?: string;     // JSONPath filter on edge.data
  node_jsonpath_filter?: string;     // JSONPath filter on node.data
  max_depth?: number;                // Traversal depth (default: 1)
  is_general_type?: boolean;         // Use general_type_name vs specific_type_name
  page?: number;                     // Page number (default: 0)
  size?: number;                     // Results per page (default: 10)
  sort_column?: SortColumn | SortColumn[];  // Sort field(s)
  sort_direction?: SortDirection | SortDirection[];  // Sort order(s)
  search_query?: string;             // Full-text search on node data
}
```

**SortColumn:**
- `'modified'` - Sort by modified
- `'created'` - Sort by created
- `'position'` - Sort by edge position

**SortDirection:**
- `'ASC'` - Ascending order
- `'DESC'` - Descending order

**Returns:**

```typescript
ConnectedNodesFiltered {
  ...EntityNodeDTO,  // Starting node fields
  from_edges: {
    [edgeType: string]: Array<EntityNodeDTO & {
      edge_data: JSONObject;  // Edge data embedded with node
    }>;
  };
}
```

**JSONPath Filter Syntax:**
```sql
-- Examples of valid JSONPath filters

-- Exact match
'$.type == "document"'

-- Numeric comparison
'$.priority > 5'

-- Nested field
'$.metadata.status == "published"'

-- Array contains
'$.tags[*] == "urgent"'

-- Logical operators
'$.type == "document" && $.status == "active"'
```

**Behavior:**
- Calls PostgreSQL UDF: `entity.get_connected_nodes_page()`
- Supports complex filtering on both nodes and edges
- Includes edge data with each returned node
- Supports multi-column sorting
- Efficient pagination for large result sets

**Examples:**

```typescript
// Simple pagination
const page1 = await client.find_connected_nodes_by_jsonpath(
  folderId,
  'contains',
  {
    page: 1,
    size: 20,
    sort_column: 'modified',
    sort_direction: 'DESC'
  }
);

// Filter by node type
const documents = await client.find_connected_nodes_by_jsonpath(
  folderId,
  'contains',
  {
    node_jsonpath_filter: '$.type == "document"',
    size: 50
  }
);

// Filter by edge properties
const highPriority = await client.find_connected_nodes_by_jsonpath(
  projectId,
  'task',
  {
    edge_jsonpath_filter: '$.priority >= 8',
    sort_column: 'position',
    sort_direction: 'ASC'
  }
);

// Deep traversal with filters
const activeSubtree = await client.find_connected_nodes_by_jsonpath(
  rootId,
  'contains',
  {
    max_depth: 5,
    node_jsonpath_filter: '$.status == "active"',
    size: 100
  }
);

// Multi-column sort
const sorted = await client.find_connected_nodes_by_jsonpath(
  nodeId,
  'connects',
  {
    sort_column: ['modified', 'position'],
    sort_direction: ['DESC', 'ASC'],
    size: 20
  }
);

// Full-text search
const searchResults = await client.find_connected_nodes_by_jsonpath(
  folderId,
  'contains',
  {
    search_query: 'quarterly report',
    size: 10
  }
);

// Access results
const node = page1;  // Starting node
const children = page1.from_edges['contains'] || [];

for (const child of children) {
  console.log('Node:', child.name);
  console.log('Edge data:', child.edge_data);  // Edge properties
}
```

**Performance Tips:**
- Use `size` to limit result sets and avoid loading too much data
- Add filters to reduce traversal scope
- Lower `max_depth` for faster queries
- Use appropriate indexes on filtered fields

---

### Search Operations

#### search_nodes

General-purpose node search across the entire database.

**Signature:**
```typescript
search_nodes<T extends JSONObject>(
  condition?: Conditions,
  order_by?: OrderBy,
  pagination?: Pagination
): Promise<{ result: EntityInstanceNodeDTO<T>[]; total: number }>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `condition` | `Conditions` | No | `{}` | Filter conditions (see Conditions type above) |
| `order_by` | `OrderBy` | No | `{}` | Sort specification |
| `pagination` | `Pagination` | No | `{ page: 1, size: 10 }` | Result pagination |

**Returns:**

```typescript
{
  result: EntityInstanceNodeDTO<T>[];  // Matching nodes
  total: number;                       // Total count (for pagination)
}
```

**Behavior:**
- Searches ALL nodes in database (not scoped to app_id)
- Should manually include `app_id` in conditions for scoping
- Returns instance nodes (nodes with `data` field)
- `total` reflects total matches (not just current page)

**Example:**
```typescript
// Search with filters
const results = await client.search_nodes(
  {
    app_id: myAppId,  // Manual scoping
    status: 'InProgress',
    specific_type_name: 'Workflow'
  },
  { modified: 'desc' },
  { page: 1, size: 20 }
);

console.log(`Found ${results.total} workflows`);
console.log(`Showing ${results.result.length} results`);

// Complex query
const complex = await client.search_nodes(
  {
    $and: [
      { status: { $in: ['Pending', 'InProgress'] } },
      { created: { $gt: '2024-01-01T00:00:00Z' } },
      { data: { '@>': { type: 'report' } } }
    ]
  },
  { priority: 'desc', created: 'asc' },
  { page: 1, size: 50 }
);
```

**Security Note:**
- Not automatically scoped to `app_id`
- Always include `app_id` in conditions for multi-tenant safety
- Or use `search_nodes_scoped` instead

---

#### search_nodes_scoped

App-scoped node search (automatically filters by app_id).

**Signature:**
```typescript
search_nodes_scoped<T extends JSONObject>(
  condition?: Conditions,
  order_by?: OrderBy,
  pagination?: Pagination
): Promise<{ result: EntityInstanceNodeDTO<T>[]; total: number }>
```

**Parameters:**

Same as `search_nodes` (see above)

**Returns:**

Same as `search_nodes`

**Behavior:**
- Automatically adds `app_id` filter from client constructor
- Ensures data isolation between applications
- Otherwise identical to `search_nodes`

**Example:**
```typescript
// Automatically scoped to client's app_id
const results = await client.search_nodes_scoped(
  {
    status: 'Completed',
    'data->report_type': 'monthly'
  },
  { created: 'desc' },
  { page: 1, size: 10 }
);

// No need to specify app_id - it's automatic
```

**Preferred over `search_nodes` for:**
- Application code (not admin tools)
- Multi-tenant environments
- When you always want app-scoped results

---

#### search_udf

Executes a custom database search function.

**Signature:**
```typescript
search_udf<T extends JSONObject = any>(
  udf: string,
  ...args: any[]
): Promise<T[]>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `udf` | `string` | Yes | Name of database function (schema.function_name) |
| `args` | `any[]` | No | Function arguments (variadic) |

**Returns:**

`T[]` - Array of results (structure depends on UDF)

**Behavior:**
- Executes: `SELECT * FROM {udf}($1, $2, ...)`
- Passes arguments as PostgreSQL parameters
- Type parameter `T` defines expected result shape
- Useful for complex queries not covered by standard methods

**Example:**
```typescript
// Call custom search function
const results = await client.search_udf<{
  node_id: UUID;
  score: number;
  metadata: JSONObject;
}>(
  'entity.search_by_custom_algorithm',
  myAppId,
  'search term',
  { threshold: 0.7 }
);

for (const result of results) {
  console.log(`Node ${result.node_id}: score ${result.score}`);
}
```

**Requirements:**
- Database function must exist
- Function should return `SETOF record` or table
- Arguments must be PostgreSQL-compatible types

---

### Node I/O Operations

#### get_node_io

Retrieves input/output schema for a node.

**Signature:**
```typescript
get_node_io(
  id: UUID
): Promise<{
  input?: JSONObject;
  output?: JSONObject;
  progress?: JSONObject[];
} | undefined>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Node ID |

**Returns:**

```typescript
{
  input?: JSONObject;      // Input schema/data
  output?: JSONObject;     // Output schema/data
  progress?: JSONObject[]; // Progress events array
} | undefined  // undefined if no I/O record exists
```

**Behavior:**
- Queries `entity.node_io` table
- Returns `undefined` if no I/O record exists (not an error)
- I/O data is optional and managed separately from node data

**Example:**
```typescript
const io = await client.get_node_io(runnableId);

if (io) {
  console.log('Input:', io.input);
  console.log('Output:', io.output);
  console.log('Progress events:', io.progress?.length);
} else {
  console.log('No I/O data for this node');
}
```

---

#### get_node_progress

Retrieves only the progress array for a node.

**Signature:**
```typescript
get_node_progress(
  id: UUID
): Promise<{ progress?: JSONObject[] } | undefined>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Node ID |

**Returns:**

`{ progress?: JSONObject[] } | undefined`

**Behavior:**
- More efficient than `get_node_io` if you only need progress
- Returns `undefined` if no I/O record exists

**Example:**
```typescript
const progressData = await client.get_node_progress(runnableId);

if (progressData?.progress) {
  for (const event of progressData.progress) {
    console.log('Progress:', event);
  }
}
```

---

#### set_node_io

Sets input/output schema for a node (upsert).

**Signature:**
```typescript
set_node_io(
  id: UUID,
  io: { input?: JSONObject; output?: JSONObject }
): Promise<{ input?: JSONObject; output?: JSONObject }>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `id` | `UUID` | Yes | Node ID |
| `io.input` | `JSONObject` | No | Input schema/data |
| `io.output` | `JSONObject` | No | Output schema/data |

**Returns:**

```typescript
{
  input?: JSONObject;   // Updated input (or existing if not provided)
  output?: JSONObject;  // Updated output (or existing if not provided)
}
```

**Behavior:**
- Uses `INSERT ... ON CONFLICT UPDATE` (upsert)
- Fields not provided are preserved
- Use `COALESCE` to merge with existing values

**Example:**
```typescript
// Set input schema
await client.set_node_io(runnableId, {
  input: {
    type: 'object',
    properties: {
      query: { type: 'string' }
    }
  }
});

// Set output schema
await client.set_node_io(runnableId, {
  output: {
    type: 'object',
    properties: {
      results: { type: 'array' }
    }
  }
});

// Set both
await client.set_node_io(runnableId, {
  input: { /* schema */ },
  output: { /* schema */ }
});
```

---

#### append_node_io_progress

Appends a progress event to the progress array.

**Signature:**
```typescript
append_node_io_progress(
  node_id: UUID,
  envelope: JSONObject
): Promise<{
  input?: JSONObject;
  output?: JSONObject;
  progress?: JSONObject[];
}>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `node_id` | `UUID` | Yes | Node ID |
| `envelope` | `JSONObject` | Yes | Progress event object |

**Returns:**

Full I/O record including updated progress array

**Behavior:**
- Uses `INSERT ... ON CONFLICT UPDATE` with array append (`||`)
- Creates I/O record if it doesn't exist
- Appends to end of progress array
- Each event should have unique ID for deduplication (application logic)

**Example:**
```typescript
// Log progress event
await client.append_node_io_progress(runnableId, {
  id: generateUUID(),
  timestamp: Date.now(),
  step: 'processing',
  progress: 50,
  message: 'Halfway done'
});

// Stream progress events
for (let i = 0; i <= 100; i += 10) {
  await client.append_node_io_progress(runnableId, {
    id: generateUUID(),
    timestamp: Date.now(),
    progress: i
  });
}
```

**Progress Event Structure (typical):**
```typescript
{
  id: UUID;              // Unique event ID
  timestamp: number;     // Unix timestamp
  step?: string;         // Current step name
  progress?: number;     // 0-100 percentage
  message?: string;      // Human-readable message
  data?: JSONObject;     // Additional data
}
```

---

### Vector Operations

#### create_node_embedding

Creates a vector embedding for a node (for similarity search).

**Signature:**
```typescript
create_node_embedding(
  node_id: UUID,
  embedding: number[],
  metadata?: JSONObject
): Promise<UUID>
```

**Parameters:**

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `node_id` | `UUID` | Yes | Node to associate embedding with |
| `embedding` | `number[]` | Yes | Embedding vector (must be length 3072) |
| `metadata` | `JSONObject` | No | Additional metadata for filtering |

**Returns:**

`UUID` - ID of created embedding record

**Constraints:**
- **Embedding dimension must be exactly 3072** (matches `halfvec(3072)` column)
- Use `text-embedding-3-large` model from OpenAI
- Each node can have multiple embeddings (versioning)

**Behavior:**
- Inserts into `entity.vector_similarity` table
- Uses pgvector extension for efficient similarity search
- Stores as `halfvec(3072)` for storage efficiency

**Example:**
```typescript
// Create embedding for a node
const embeddingId = await client.create_node_embedding(
  nodeId,
  embeddingVector,  // 3072-dimensional array
  {
    model: 'text-embedding-3-large',
    version: '1.0',
    source: 'node-data-field'
  }
);

console.log('Created embedding:', embeddingId);
```

**Error Handling:**
- Throws `FFError` if dimension mismatch (must be 3072)
- Throws `FFError` if node doesn't exist
- Throws `FFError` for database errors

---

#### find_similar_nodes

Finds nodes similar to a given node via vector similarity.

**Signature:**
```typescript
find_similar_nodes(
  node_id: UUID,
  limit?: number,
  threshold?: number,
  metadataFilters?: JSONObject,
  orderConfig?: OrderConfig
): Promise<SimilaritySearchResult[]>
```

**Parameters:**

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `node_id` | `UUID` | Yes | - | Source node ID |
| `limit` | `number` | No | `10` | Maximum results |
| `threshold` | `number` | No | none | Minimum similarity (0-1) |
| `metadataFilters` | `JSONObject` | No | none | JSONB containment filter |
| `orderConfig` | `OrderConfig` | No | none | Secondary sorting |

**OrderConfig:**
```typescript
{
  orderBy?: 'modified' | 'created';      // Node field to sort by
  orderDirection?: 'ASC' | 'DESC';       // Sort order
}
```

**Returns:**

```typescript
SimilaritySearchResult[] = Array<{
  node_id: UUID;        // Matching node ID
  similarity: number;   // Similarity score (0-1, higher = more similar)
  metadata: JSONObject; // Embedding metadata
}>
```

**Behavior:**
- Retrieves embedding for `node_id`
- Uses cosine distance: `embedding <=> source_embedding`
- Filters by threshold: `distance <= (1 - threshold)`
- Orders by distance (primary) and orderConfig (secondary)
- Excludes source node from results

**Example:**
```typescript
// Find 10 most similar nodes
const similar = await client.find_similar_nodes(nodeId, 10);

for (const result of similar) {
  console.log(`Node ${result.node_id}: ${result.similarity.toFixed(3)}`);
}

// With threshold filter
const verySimilar = await client.find_similar_nodes(
  nodeId,
  20,
  0.8  // Only nodes with similarity >= 0.8
);

// With metadata filtering
const similarDocs = await client.find_similar_nodes(
  nodeId,
  10,
  0.7,
  { type: 'document', language: 'en' }  // JSONB @> operator
);

// With secondary sort
const recent = await client.find_similar_nodes(
  nodeId,
  20,
  undefined,
  undefined,
  { orderBy: 'modified', orderDirection: 'DESC' }
);
```

**Distance to Similarity Conversion:**
- Cosine distance: 0 = identical, 2 = opposite
- Similarity = 1 - (distance / 2)
- Similarity range: [0, 1] where 1 = identical

---

#### search_by_embedding

Searches for nodes similar to a given embedding vector.

**Signature:**
```typescript
search_by_embedding(
  embedding: number[],
  limit?: number,
  threshold?: number,
  metadataFilters?: JSONObject,
  orderConfig?: OrderConfig
): Promise<SimilaritySearchResult[]>
```

**Parameters:**

Same as `find_similar_nodes` except first parameter:

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `embedding` | `number[]` | Yes | - | Query embedding vector (3072-dim) |

**Returns:**

Same as `find_similar_nodes`

**Behavior:**
- Directly searches by embedding vector (no node lookup needed)
- Useful when you have embedding but no associated node
- Otherwise identical to `find_similar_nodes`

**Example:**
```typescript
// Search by raw embedding
const queryEmbedding = await generateEmbedding('search query text');

const results = await client.search_by_embedding(
  queryEmbedding,
  10,
  0.75
);

// With filters
const filtered = await client.search_by_embedding(
  queryEmbedding,
  20,
  0.7,
  { category: 'technical', published: true },
  { orderBy: 'modified', orderDirection: 'DESC' }
);

// Process results
for (const result of results) {
  const node = await client.get_node(result.node_id);
  console.log(`Match: ${node?.name} (${result.similarity.toFixed(3)})`);
}
```

**Use Cases:**
- Semantic search: Convert query text to embedding, search for similar nodes
- RAG systems: Find relevant context for LLM prompts
- Recommendation: Find similar items based on user preferences
- Duplicate detection: Find near-duplicate content

---

### Utility Methods

#### get_health

Health check for liveness probe.

**Signature:**
```typescript
// Not exposed in RemoteEntityClient
// Available via direct HTTP: GET /health
```

**Returns:**
```json
{
  "status": "healthy",
  "timestamp": "2024-10-25T12:00:00.000Z"
}
```

---

#### get_readiness

Readiness check for readiness probe.

**Signature:**
```typescript
// Not exposed in RemoteEntityClient
// Available via direct HTTP: GET /ready
```

**Returns:**
```json
{
  "ready": true,
  "database": "connected"
}
```

#### Node Operations with Error Handling

```typescript
// Robust node retrieval
async function getNodeSafely(
  client: RemoteEntityClient,
  nodeId: UUID
): Promise<EntityNodeDTO | null> {
  try {
    const node = await client.get_node(nodeId);
    if (!node) {
      console.log(`Node ${nodeId} not found`);
      return null;
    }
    return node;
  } catch (error) {
    if (error instanceof FFError) {
      console.error(`Failed to get node: ${error.message}`);
    }
    throw error;
  }
}

// Batch retrieval with filtering
async function getExistingNodes(
  client: RemoteEntityClient,
  nodeIds: UUID[]
): Promise<EntityNodeDTO[]> {
  const nodes = await client.get_node(nodeIds);
  return nodes.filter((node): node is EntityNodeDTO => node !== undefined);
}
```

#### Complex Graph Traversal

```typescript
// Build a complete project tree
async function buildProjectTree(
  client: RemoteEntityClient,
  projectId: UUID,
  maxDepth: number = 3
): Promise<JSONObject> {
  try {
    // Use UDF for efficient deep traversal
    const tree = await client.get_connected_nodes_udf(
      projectId,
      'contains',  // Edge type
      maxDepth
    );
    
    return tree;
  } catch (error) {
    console.error('Failed to build project tree:', error);
    throw error;
  }
}

// Find all dependencies with filtering
async function findDependencies(
  client: RemoteEntityClient,
  nodeId: UUID,
  filters?: JSONObject
): Promise<EntityNodeDTO[]> {
  const result = await client.find_connected_nodes_by_jsonpath(
    nodeId,
    'depends_on',
    {
      node_jsonpath_filter: filters 
        ? `$.data.type == "${filters.type}"`
        : undefined,
      max_depth: 5,
      page: 1,
      size: 100,
      sort_column: 'modified',
      sort_direction: 'DESC'
    }
  );
  
  // Extract nodes from the from_edges structure
  const nodes: EntityNodeDTO[] = [];
  for (const edgeList of Object.values(result.from_edges)) {
    nodes.push(...edgeList);
  }
  
  return nodes;
}
```

#### Conditional Updates

```typescript
// Claim a job from a queue atomically
async function claimJob(
  client: RemoteEntityClient,
  appId: UUID,
  jobId: UUID
): Promise<boolean> {
  const rowCount = await client.update_node_status_conditional(
    jobId,
    'InProgress',           // New status
    'Pending'               // Required current status
  );
  
  return rowCount > 0;  // true if successfully claimed
}

// Retry pattern for claiming jobs
async function claimJobWithRetry(
  client: RemoteEntityClient,
  appId: UUID,
  jobIds: UUID[],
  maxAttempts: number = 3
): Promise<UUID | null> {
  for (const jobId of jobIds) {
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const claimed = await claimJob(client, appId, jobId);
      if (claimed) {
        return jobId;
      }
      // Small delay before retry
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  return null;  // No job claimed
}
```

---

## Error Handling

### Error Types

All errors are transformed to `FFError`:

```typescript
import { FFError } from '@firebrandanalytics/shared-types';

try {
  const node = await client.get_node(nodeId);
} catch (error) {
  if (error instanceof FFError) {
    // Structured error with message and optional statusCode
    console.error('Operation failed:', error.message);
    if ((error as any).statusCode) {
      console.error('Status:', (error as any).statusCode);
    }
  }
}
```

### Common Error Scenarios

#### 404 Not Found

```typescript
// Single node - returns undefined
const node = await client.get_node(nonExistentId);
if (node === undefined) {
  console.log('Node not found');
}

// Batch nodes - missing nodes omitted from array
const nodes = await client.get_node([id1, nonExistentId, id2]);
// Returns: [node1, node2] (nonExistentId skipped)
```

#### 401 Unauthorized (External Mode)

```typescript
try {
  const client = new RemoteEntityClient('http://gateway', app_id, {
    mode: 'external',
    api_key: 'invalid-key',
    namespace: 'ff-dev'
  });
  
  const node = await client.get_node(nodeId);
} catch (error) {
  // FFError with 401 status
  console.error('Authentication failed');
}
```

#### 409 Conflict (Duplicate)

```typescript
const node = await client.create_node_if_not_exists({
  app_id: app_id,
  name: 'unique-node',
  general_type_name: 'Entity',
  specific_type_name: 'MyEntity',
  data: {}
});

if (node === null) {
  console.log('Node already exists');
} else {
  console.log('Node created:', node.id);
}
```

#### Timeout

```typescript
const client = new RemoteEntityClient('http://entity-service', app_id, {
  mode: 'internal',
  timeout: 5000  // 5 seconds
});

try {
  // This might timeout for complex queries
  const results = await client.find_connected_nodes_by_jsonpath(
    nodeId,
    'complex_edge',
    { max_depth: 10 }
  );
} catch (error) {
  if (error.message.includes('timeout')) {
    console.error('Query timed out - try reducing max_depth or increasing timeout');
  }
}
```

### Error Handling Patterns

#### Retry Logic

```typescript
async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  delay: number = 1000
): Promise<T> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
      
      console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2;  // Exponential backoff
    }
  }
  
  throw new Error('Retry logic failed');
}

// Usage
const node = await withRetry(
  () => client.get_node(nodeId),
  3,
  1000
);
```

#### Circuit Breaker

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailTime = 0;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  constructor(
    private threshold: number = 5,
    private timeout: number = 60000
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailTime > this.timeout) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker is open');
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = 'closed';
  }
  
  private onFailure() {
    this.failures++;
    this.lastFailTime = Date.now();
    if (this.failures >= this.threshold) {
      this.state = 'open';
    }
  }
}

// Usage
const breaker = new CircuitBreaker(5, 60000);
const node = await breaker.execute(() => client.get_node(nodeId));
```

---

## Best Practices

### 1. Client Initialization

```typescript
// ✅ Create one client instance per app_id and reuse it
class EntityService {
  private client: RemoteEntityClient;
  
  constructor(appId: UUID) {
    this.client = new RemoteEntityClient(
      'http://entity-service',
      appId,
      { mode: 'internal' }
    );
  }
  
  async getNode(nodeId: UUID) {
    return this.client.get_node(nodeId);
  }
}

// ❌ Don't create new clients for every request
async function getNode(nodeId: UUID) {
  const client = new RemoteEntityClient(/* ... */);  // Inefficient
  return client.get_node(nodeId);
}
```

### 2. Batch Operations

```typescript
// ✅ Use batch methods for multiple entities
const nodeIds = [id1, id2, id3, id4, id5];
const nodes = await client.get_node(nodeIds);  // Single request

// ❌ Don't make individual requests
const nodes = await Promise.all(
  nodeIds.map(id => client.get_node(id))  // Multiple requests
);
```

### 3. Error Handling

```typescript
// ✅ Handle 404s appropriately
const node = await client.get_node(nodeId);
if (!node) {
  // Handle missing node
  return createDefaultNode();
}

// ✅ Use try-catch for other errors
try {
  const node = await client.create_node(nodeData);
} catch (error) {
  if (error instanceof FFError) {
    // Handle specific error cases
    logError(error);
  }
  throw error;
}
```

### 4. Timeouts

```typescript
// ✅ Set appropriate timeouts based on operation complexity
const quickClient = new RemoteEntityClient(url, appId, {
  mode: 'internal',
  timeout: 5000  // 5s for simple queries
});

const heavyClient = new RemoteEntityClient(url, appId, {
  mode: 'internal',
  timeout: 120000  // 120s for complex operations
});

// ✅ Or use per-operation timeout wrappers
async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> {
  const timeout = new Promise<never>((_, reject) =>
    setTimeout(() => reject(new Error('Timeout')), timeoutMs)
  );
  return Promise.race([promise, timeout]);
}

const node = await withTimeout(
  client.get_connected_nodes_udf(id, 'complex', 10),
  30000
);
```

### 5. Scoped Searches

```typescript
// ✅ Use scoped searches to ensure app isolation
const results = await client.search_nodes_scoped(
  { status: 'active' },
  { created: 'desc' }
);

// ⚠️ Unscoped search may return nodes from other apps
const results = await client.search_nodes(
  { status: 'active', app_id: appId },  // Must manually filter
  { created: 'desc' }
);
```

### 6. Connection Pooling

```typescript
// ✅ Rely on axios's connection management
// The client internally uses axios which pools connections

// ⚠️ If you need custom pooling behavior:
import { Agent } from 'http';

const agent = new Agent({
  keepAlive: true,
  maxSockets: 10
});

// Note: Current implementation doesn't expose agent configuration
// Contact FireFoundry team if you need custom pooling
```

---

## Troubleshooting

### Connection Issues

#### "ECONNREFUSED" Error

```
Error: connect ECONNREFUSED 127.0.0.1:8080
```

**Causes:**
- Entity service is not running
- Wrong host/port configuration
- Network policy blocking connection

**Solutions:**
```typescript
// 1. Verify service is running
kubectl get pods -n ff-dev | grep entity-service

// 2. Check service endpoint
kubectl get svc entity-service -n ff-dev

// 3. Test connectivity from your pod
kubectl exec -it your-pod -- curl http://entity-service:8080/health

// 4. Verify client configuration
const client = new RemoteEntityClient(
  'http://entity-service',  // Use service name, not localhost
  app_id,
  { mode: 'internal', internal_port: 8080 }
);
```

#### "Timeout" Error

```
Error: timeout of 200000ms exceeded
```

**Solutions:**
```typescript
// 1. Increase timeout for heavy operations
const client = new RemoteEntityClient(url, appId, {
  mode: 'internal',
  timeout: 300000  // 5 minutes
});

// 2. Optimize your query
// Instead of deep traversal:
const tree = await client.get_connected_nodes_udf(id, 'contains', 10);  // Slow

// Use pagination:
const page1 = await client.find_connected_nodes_by_jsonpath(
  id,
  'contains',
  { max_depth: 2, page: 1, size: 50 }
);

// 3. Check entity service logs
kubectl logs -n ff-dev deployment/entity-service
```

### Authentication Issues

#### "401 Unauthorized"

```
Error: Request failed with status code 401
```

**Causes:**
- Invalid API key
- Expired API key
- Missing API key

**Solutions:**
```typescript
// 1. Verify API key is set
console.log('API key:', process.env.FIREFOUNDRY_API_KEY ? 'Set' : 'Missing');

// 2. Test API key
curl -H "Authorization: Bearer $FIREFOUNDRY_API_KEY" \
  http://gateway:30080/core/ff-dev/entity-service/health

// 3. Request new API key from administrator

// 4. Verify mode is 'external'
const client = new RemoteEntityClient(url, appId, {
  mode: 'external',  // Required for API key auth
  api_key: process.env.FIREFOUNDRY_API_KEY,
  namespace: 'ff-dev'
});
```

### Configuration Issues

#### "api_key is required for external mode"

```
FFError: api_key is required for external mode
```

**Solution:**
```typescript
// Add api_key to options
const client = new RemoteEntityClient(url, appId, {
  mode: 'external',
  api_key: process.env.FIREFOUNDRY_API_KEY,  // Add this
  namespace: 'ff-dev'
});
```

#### "namespace should not be provided for internal mode"

```
FFError: namespace should not be provided for internal mode
```

**Solution:**
```typescript
// Remove namespace from internal mode
const client = new RemoteEntityClient(url, appId, {
  mode: 'internal'
  // namespace: 'ff-dev'  // Remove this
});
```

### Query Issues

#### Empty Results

```typescript
const nodes = await client.search_nodes_scoped({ status: 'active' });
// Returns: { result: [], total: 0 }
```

**Debugging:**
```typescript
// 1. Verify data exists
const allNodes = await client.search_nodes_scoped({});
console.log('Total nodes:', allNodes.total);

// 2. Check your filter conditions
const nodes = await client.search_nodes_scoped(
  { 
    // status: 'active'  // Try without filter
  }
);

// 3. Verify app_id scoping
const unscoped = await client.search_nodes({ app_id: appId });
// Compare with scoped version

// 4. Check database directly
// kubectl exec -it postgres-pod -- psql -U user -d db
// SELECT * FROM entity.node WHERE app_id = '<your-app-id>';
```

#### Slow Queries

```typescript
// Query takes >30 seconds
const results = await client.find_connected_nodes_by_jsonpath(
  nodeId,
  'complex_relationship',
  { max_depth: 10 }
);
```

**Optimization:**
```typescript
// 1. Reduce max_depth
const results = await client.find_connected_nodes_by_jsonpath(
  nodeId,
  'complex_relationship',
  { max_depth: 3 }  // Reduced from 10
);

// 2. Add pagination
const results = await client.find_connected_nodes_by_jsonpath(
  nodeId,
  'complex_relationship',
  {
    max_depth: 5,
    page: 1,
    size: 50
  }
);

// 3. Use filters to reduce result set
const results = await client.find_connected_nodes_by_jsonpath(
  nodeId,
  'complex_relationship',
  {
    max_depth: 5,
    node_jsonpath_filter: '$.data.type == "specific_type"'
  }
);

// 4. Check if index exists on commonly filtered fields
// Contact FireFoundry team for database optimization
```

### Debugging Tools

#### Enable Request Logging

The client uses the `@firebrandanalytics/shared-utils` logger. Configure logging level:

```typescript
import { logger } from '@firebrandanalytics/shared-utils';

// Set log level to debug
logger.level = 'debug';

// Now all requests/responses are logged
const node = await client.get_node(nodeId);
// Logs:
// [DEBUG] RemoteEntityClient request: { method: 'get', url: '/api/node/123', ... }
// [DEBUG] RemoteEntityClient response: { status: 200, ... }
```

#### Inspect Network Traffic

```bash
# From your pod
kubectl exec -it your-pod -- sh

# Install tcpdump if available
apk add tcpdump

# Capture traffic to entity-service
tcpdump -i any -A host entity-service

# Or use curl to test
curl http://entity-service:8080/api/node/<node-id> \
  -H "X-App-ID: <your-app-id>"
```

#### Check Entity Service Health

```bash
# Health check
curl http://entity-service:8080/health

# Readiness check
curl http://entity-service:8080/ready

# Service status
curl http://entity-service:8080/status
```

---

## Additional Resources

### Related Documentation

- [Entity Service API Documentation](../ff-services-entity/README.md)
- [FireFoundry Platform Overview](../docs/README.md)
- [Agent SDK Guide](../ff-agent-sdk/README.md)
- [Management Console User Guide](../docs/console/README.md)

### Support

- **Platform Issues**: Contact FireFoundry platform team
- **API Questions**: Check entity service documentation
- **Configuration Help**: Consult with your platform administrator
- **Bug Reports**: Submit via internal issue tracker

### Version History

See [CHANGELOG.md](./CHANGELOG.md) for version history and migration guides.

---

**Document Version**: 1.0.0  
**Last Updated**: 2025-10-25  
**Client Version**: 0.1.1
