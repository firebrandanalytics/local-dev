# Waitable Runnable Entity Guide

## Overview

Waitable Runnable Entities extend the standard runnable entity pattern to support **human-in-the-loop workflows** and **external input integration**. They can pause execution, wait for external input (potentially for days, months, or years), and then resume processing with the received data.

## Key Concepts

### 1. Dual Interaction Patterns

Waitable entities support two distinct interaction patterns depending on whether you have access to the execution iterator:

#### Pattern A: Iterator-Based (Bidirectional Yield)
- Used when you own/control the iterator
- Messages are sent through the yield mechanism
- Synchronous communication pattern

#### Pattern B: Promise-Based (sendMessage)
- Used when you don't have access to the iterator
- Messages are sent via `sendMessage()` method calls
- Asynchronous communication through promise resolution
- **Ideal for REST API interactions and external systems**

### 2. Core Architecture

```typescript
export default class WaitableRunnableEntityClass<
  ENH extends RunnableEntityTypeHelper<any, any, any, any, { message: string; data: any }>
> extends RunnableEntityClass<ENH> {
  // Promise-based messaging
  protected message_promise?: Promise<any>;
  protected message_resolve?: (result: any) => void;
  
  // External message injection
  public sendMessage(message: string, data: any): void
  
  // Override point for message handling
  protected async *message_handler(message: string, data: any): RunnableEntityResponseGenerator<...>
  
  // Create waiting envelopes
  protected async createWaitingEnvelope(message?: string, data?: any): Promise<RunnableEntityProgressWaitingEnvelope>
}
```

## Implementation Patterns

### 1. Basic Waitable Entity

```typescript
@WaitableRunnableEntityDecorator({
    generalType: 'Step',
    specificType: 'UserReviewStep',
    allowedConnections: {}
})
export class UserReviewStep extends AddInterface<typeof Step<RETH['enh']>, WaitableRunnableEntityClass<RETH>>(Step<RETH['enh']>) {
    
    protected override async *run_impl(): RunnableEntityResponseGenerator<...> {
        // Yield waiting envelope to signal we're waiting for input
        const message = yield this.createWaitingEnvelope(
            "Provide your review for the job description generated by the AI."
        );
        
        // Return the received message (or processed result)
        return message;
    }

    // External API methods for sending messages
    public approve() {
        this.sendMessage('approved', true);
    }

    public giveFeedback(feedback: string) {
        this.sendMessage('feedback', feedback);
    }
}
```

### 2. Multi-Message Type Handling

```typescript
export type ReviewStepOutput = 
    | { message: 'approved'; data: boolean } 
    | { message: 'feedback'; data: string };

export class UserReviewStep extends WaitableRunnableEntityClass<RETH> {
    protected override async *run_impl(): RunnableEntityResponseGenerator<...> {
        const message = yield this.createWaitingEnvelope(
            "Please review and either approve or provide feedback."
        );
        
        // The message object contains both message type and data
        if (message.message === 'approved') {
            // Handle approval
            return { status: 'approved', approved: message.data };
        } else if (message.message === 'feedback') {
            // Handle feedback - might trigger additional processing
            const processedFeedback = await this.processFeedback(message.data);
            return { status: 'feedback_received', feedback: processedFeedback };
        }
        
        throw new Error(`Unknown message type: ${message.message}`);
    }
    
    private async processFeedback(feedback: string) {
        // Process the feedback, maybe call other entities
        return `Processed: ${feedback}`;
    }
}
```

### 3. Credential-Based Waitable (Secure Pattern)

```typescript
@WaitableRunnableEntityDecorator({
    generalType: 'Auth',
    specificType: 'OAuthStep',
    allowedConnections: {}
})
export class OAuthStep extends WaitableRunnableEntityClass<RETH> {
    protected override async *run_impl(): RunnableEntityResponseGenerator<...> {
        // Wait for OAuth credentials
        const message = yield this.createWaitingEnvelope(
            "Please provide OAuth authorization.",
            { redirectUrl: "https://api.example.com/oauth/authorize" }
        );
        
        // Use credentials to fetch data, but don't store credentials
        const credentials = message.data;
        const userData = await this.fetchUserData(credentials);
        
        // Return only the fetched data, credentials are not persisted
        return {
            userId: userData.id,
            profile: userData.profile,
            // credentials are NOT included in return value
        };
    }
    
    public provideCredentials(accessToken: string, refreshToken: string) {
        this.sendMessage('oauth_complete', {
            accessToken,
            refreshToken
        });
    }
    
    private async fetchUserData(credentials: any) {
        // Use credentials to make API calls
        // This happens in memory, credentials won't be persisted
        return await externalAPI.getUser(credentials.accessToken);
    }
}
```

### 4. ID-Based Lookup Waitable

```typescript
@WaitableRunnableEntityDecorator({
    generalType: 'DataStep',
    specificType: 'EntityLookupStep',
    allowedConnections: {}
})
export class EntityLookupStep extends WaitableRunnableEntityClass<RETH> {
    protected override async *run_impl(): RunnableEntityResponseGenerator<...> {
        const message = yield this.createWaitingEnvelope(
            "Please provide the entity ID to lookup."
        );
        
        // Use received ID to lookup entity
        const entityId = message.data.entityId;
        const entity = await this.factory.get_entity(entityId);
        const entityData = await entity.get_dto();
        
        // Return the full entity data, not just the ID
        return {
            entityId: entityId,
            entityData: entityData,
            lookupTimestamp: new Date().toISOString()
        };
    }
    
    public provideEntityId(entityId: string) {
        this.sendMessage('entity_id', { entityId });
    }
}
```

### 5. Interactive Clarification Waitable

```typescript
@WaitableRunnableEntityDecorator({
    generalType: 'EntityMessage',
    specificType: 'EntityClarifyingPrompt',
    allowedConnections: {}
})
export class EntityClarifyingPrompt extends WaitableRunnableEntityClass<RETH> {
    protected override async *run_impl(): RunnableEntityResponseGenerator<...> {
        const dto = await this.get_dto();
        
        // Provide structured choices to the user
        const choices = Array.isArray(dto.data.choices) ? dto.data.choices : [];
        const waitingData = {
            prompt: dto.data.prompt,
            choices: choices
        };

        const message = yield this.createWaitingEnvelope(dto.data.prompt, waitingData);
        return message;
    }

    // Override message_handler if you need to do processing when receiving messages
    override async* message_handler(message: string, data: any) {
        // Return false to indicate we don't want to continue processing more messages
        // Return true if this waitable can handle multiple messages
        return false;
    }

    public answerQuestion(answer: string) {
        this.sendMessage('answer', answer);
    }
}
```

## Message Handler Pattern

The `message_handler` method provides a hook for processing incoming messages and controlling whether the waitable continues to accept more messages:

```typescript
protected async *message_handler(
    message: string, 
    data: any
): RunnableEntityResponseGenerator<...> {
    // Process the incoming message
    logger.detail('Received message', { message, data });
    
    // Perform any side effects or validation
    if (message === 'cancel') {
        await this.handleCancellation();
        return true; // Continue accepting messages
    }
    
    // Return false to stop accepting messages (typical pattern)
    // Return true to continue accepting more messages
    return false;
}
```

## Status Lifecycle

Waitable entities follow this status progression:

1. **Pending** → Initial state
2. **InProgress** → Execution starts
3. **Waiting** → `createWaitingEnvelope()` called, waiting for external input
4. **InProgress** → Message received, execution resumes
5. **Completed** → Execution finished successfully
6. **Failed** → Error occurred during execution

The **Waiting** status is crucial for external systems to discover entities that need input.

## External System Integration

### REST API Pattern

```typescript
// API endpoint to find waiting entities
app.get('/api/waiting-entities', async (req, res) => {
    const waitingEntities = await entityClient.findEntitiesByStatus('Waiting');
    res.json(waitingEntities.map(entity => ({
        id: entity.id,
        type: entity.specific_type_name,
        message: entity.waitingMessage,
        data: entity.waitingData
    })));
});

// API endpoint to send messages to waiting entities
app.post('/api/entities/:id/message', async (req, res) => {
    const { id } = req.params;
    const { message, data } = req.body;
    
    const entity = await factory.get_entity(id);
    if (entity instanceof WaitableRunnableEntityClass) {
        entity.sendMessage(message, data);
        res.json({ success: true });
    } else {
        res.status(400).json({ error: 'Entity is not waitable' });
    }
});
```

### Progress Monitoring

```typescript
// Monitor for waiting entities in your application
const progressIterator = await entity.start();

for await (const progress of progressIterator) {
    if (progress.type === 'WAITING') {
        // Entity is waiting for input
        console.log('Entity waiting:', {
            entityId: progress.entity_id,
            entityType: progress.entity_type,
            message: progress.message,
            data: progress.data
        });
        
        // Notify external systems or UI
        await notificationService.notifyWaitingEntity(progress);
    } else if (progress.type === 'COMPLETED') {
        console.log('Entity completed:', progress);
        break;
    }
}
```

## Best Practices

### 1. Secure Data Handling

```typescript
// ✅ Good: Don't store sensitive data in return values
protected override async *run_impl() {
    const message = yield this.createWaitingEnvelope("Enter password");
    const password = message.data.password;
    
    // Use password for authentication
    const authResult = await authenticate(password);
    
    // Return only non-sensitive results
    return { authenticated: true, userId: authResult.userId };
    // password is NOT stored in the entity
}

// ❌ Bad: Storing sensitive data
return { authenticated: true, password: password }; // Don't do this!
```

### 2. Clear Waiting Messages

```typescript
// ✅ Good: Descriptive waiting messages
yield this.createWaitingEnvelope(
    "Please review the generated job description and either approve it or provide specific feedback for improvements.",
    {
        jobDescription: generatedText,
        guidelines: ["Check for inclusivity", "Verify technical accuracy"],
        actions: ["approve", "feedback"]
    }
);

// ❌ Bad: Vague messages
yield this.createWaitingEnvelope("Waiting for input");
```

### 3. Type-Safe Message Handling

```typescript
// Define clear message types
type MessageType = 
    | { message: 'approve'; data: boolean }
    | { message: 'feedback'; data: string }
    | { message: 'cancel'; data: null };

// Handle all message types explicitly
if (message.message === 'approve') {
    return this.handleApproval(message.data);
} else if (message.message === 'feedback') {
    return this.handleFeedback(message.data);
} else if (message.message === 'cancel') {
    return this.handleCancellation();
} else {
    throw new Error(`Unknown message type: ${(message as any).message}`);
}
```

### 4. Timeout Considerations

While waitable entities don't have built-in timeouts (by design for unlimited-duration human interactions), you can implement application-level timeouts:

```typescript
// Application-level timeout monitoring
class WaitableMonitor {
    async checkStaleWaitables() {
        const oldWaitables = await entityClient.findEntitiesByStatus('Waiting', {
            olderThan: '30 days'
        });
        
        for (const entity of oldWaitables) {
            await this.handleStaleWaitable(entity);
        }
    }
    
    private async handleStaleWaitable(entity: WaitableRunnableEntityClass<any>) {
        // Send timeout message or escalate to different handler
        entity.sendMessage('timeout', { reason: 'No response after 30 days' });
    }
}
```

## Common Use Cases

1. **Human Approval Workflows**: Document review, content approval, purchase authorization
2. **Data Collection**: Forms, surveys, progressive information gathering
3. **Authentication Flows**: OAuth, multi-factor authentication, credential collection
4. **Interactive Debugging**: Pausing workflows for manual intervention
5. **External System Integration**: Waiting for webhook callbacks, third-party approvals
6. **Progressive Disclosure**: Collecting information step-by-step based on previous inputs

## Comparison with Regular Runnable Entities

| Feature | Regular Runnable | Waitable Runnable |
|---------|------------------|-------------------|
| **Execution** | Runs to completion | Can pause and resume |
| **External Input** | No | Yes, via messages |
| **Status** | Pending → InProgress → Completed | Pending → InProgress → Waiting → InProgress → Completed |
| **Persistence** | Final result only | State persisted during waiting |
| **Duration** | Short-lived | Can wait indefinitely |
| **Use Cases** | Automated processing | Human-in-the-loop workflows |

Waitable entities provide a powerful foundation for building interactive, long-running workflows that seamlessly integrate human decision-making and external system interactions into your AI-powered applications.