# FireFoundry SDK Prompting Framework Guide

*Generated by Claude*

## 1. Introduction to the FireFoundry Prompting Framework

The FireFoundry Prompting Framework is a core component of the Agent Bundle SDK, providing a powerful, flexible system for creating structured prompts for large language models (LLMs). The framework introduces a unique architecture that separates structure from content, enabling sophisticated AI workflows while maintaining clear organization and extensibility.

### 1.1 Purpose and Core Concepts

The framework serves several critical functions:

- **Structured Prompt Creation**: Build complex, multi-section prompts with consistent organization
- **Dynamic Content Generation**: Generate prompt content based on runtime context and state
- **Template Reuse**: Create reusable prompt components and patterns
- **Type Safety**: Leverage TypeScript's type system for robust prompt development
- **Working Memory Integration**: Seamlessly incorporate files and artifacts from previous steps
- **Conditional Rendering**: Control prompt content based on runtime conditions
- **Tool Integration**: Direct LLMs to use specific tools with required parameters
- **Memory Persistence**: Include context from previous interactions through memory tidbits

At its core, the framework revolves around these primary concepts:

- **Prompts**: Define the overall structure and content of LLM requests
- **Templates**: Reusable patterns for building prompt sections
- **Nodes**: Hierarchical components that make up the prompt structure
- **Groups**: Collections of related prompts that can be rendered together
- **Working Memory**: System for accessing and including external content

### 1.2 Key Components

The framework includes several key components that work together:

#### Core Components
- **`Prompt`**: Base class for all prompts, handling rendering and preprocessing
- **`PromptGroup`**: Groups of related prompts that can be rendered together
- **`ConditionalPromptGroup`**: Prompt groups with conditional rendering based on request data
- **`PromptTemplateNode`**: Base class for template nodes in the hierarchy
- **`PromptDOMNode`**: Represents the rendered prompt structure before final output

#### Template Nodes
- **`PromptTemplateTextNode`**: Simple text content
- **`PromptTemplateListNode`**: Enumerated lists with customizable formatting
- **`PromptTemplateCodeBoxNode`**: Code examples with syntax highlighting
- **`PromptTemplateSectionNode`**: Organizational sections
- **`PromptTemplateStructDataNode`**: Structured data (JSON, YAML, CSV)
- **`PromptTemplateSchemaNode`**: Schema definitions with natural language formatting
- **`PromptTemplateSchemaSetNode`**: Collections of related schemas

#### Programmatic Nodes
- **`PromptTemplateForEachNode`**: Iterate over arrays to generate content
- **`PromptTemplateIfElseNode`**: Conditional content based on boolean expressions
- **`PromptTemplateSwitchNode`**: Multi-way branching based on expression values

#### Tool Integration Nodes
- **`ToolDirectiveNode`**: Base class for tool-specific instructions
- **`RunSqlToolDirectiveNode`**: Specialized node for SQL tool usage

#### Working Memory Components
- **`WMPromptGroup`**: Advanced working memory integration with preprocessing
- **`MemoryTidbitPrompt`**: Include context from previous interactions

### 1.3 Architectural Advantages

This architecture provides several advantages:

- **Separation of Concerns**: Structure is separated from content, making prompts easier to maintain
- **Reusability**: Templates and nodes can be reused across different prompts
- **Flexibility**: Conditional logic can be applied at any level of the hierarchy
- **Extensibility**: New node types can be created for specialized needs
- **Type Safety**: TypeScript integration provides compile-time checking of prompt structures
- **Performance**: Preprocessing and caching optimize runtime performance
- **Testability**: Individual components can be tested in isolation

## 2. Getting Started with Prompt Creation

### 2.1 Basic Prompt Structure

Every prompt in the framework extends the base `Prompt` class and follows a consistent pattern:

```typescript
export default class MyPrompt extends Prompt<MY_PTH> {
    constructor(args: MY_PTH['args']['static'], options?: MY_PTH['options']) {
        super('system', args, options);
        this.add_section(this.get_Context_Section());
        this.add_section(this.get_Rules_Section());
        this.add_section(this.get_Schema_Section());
        // Add more sections as needed
    }

    // Define section methods
    get_Context_Section(): PromptTemplateNode<MY_PTH> {
        // Implementation
    }

    // More section methods...
}
```

Each prompt consists of one or more sections, each represented by a `PromptTemplateNode`. The sections are added to the prompt in the constructor, and their content is defined in separate methods.

### 2.2 Setting Up a Prompt Class

To create a new prompt, follow these steps:

1. **Define your prompt types**:

```typescript
type MY_PROMPT_INPUT = string; // Or a more complex type
type MY_PROMPT_ARGS = {
    static: {
        company?: string; // Static args available at construction
        // Other static args
    };
    request: {
        feedback_prompt?: string; // Args provided at render time
        // Other request args
    }
};

export type MY_PTH = PromptTypeHelper<MY_PROMPT_INPUT, MY_PROMPT_ARGS>;
```

2. **Create your prompt class**:

```typescript
export class MyPrompt extends Prompt<MY_PTH> {
    constructor(args: MY_PTH['args']['static'], options?: MY_PTH['options']) {
        super('system', args, options); // 'system' sets the message role
        // Add sections here
    }
}
```

3. **Add sections to your prompt**:

```typescript
constructor(args: MY_PTH['args']['static'], options?: MY_PTH['options']) {
    super('system', args, options);
    this.add_section(this.get_Context_Section());
    this.add_section(this.get_Rules_Section());
    // Add more sections
}
```

### 2.3 Understanding the Type System with PromptTypeHelper

The `PromptTypeHelper` is a type utility that helps define the types used in your prompt:

```typescript
export type PromptTypeHelper<
    I,                             // Input type
    ARGS extends PromptArgsType,   // Arguments type
    OPT extends PromptOptionsType = PromptOptionsType, // Options type
    ST extends string = PROMPT_SEMANTIC_TYPES // Semantic types
> = {
    input: I;
    args: ARGS;
    semantic_type: ST;
    options: OPT;
}
```

This provides type safety throughout your prompt implementation. The most common usage is:

```typescript
type MY_PTH = PromptTypeHelper<MY_PROMPT_INPUT, MY_PROMPT_ARGS>;
```

## 3. Building Prompt Sections

### 3.1 Using PromptTemplateSectionNode for Organization

The `PromptTemplateSectionNode` is the primary way to organize content in your prompts:

```typescript
get_Context_Section(): PromptTemplateNode<MY_PTH> {
    return new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'context',
        content: 'Context:',
        children: [
            `You are an AI assistant for ${this.static_args.company}.`,
            `Your task is to analyze financial data and provide insights.`
        ]
    });
}
```

Each section can have a title (in the `content` property) and multiple children. Children can be strings, functions that return strings, or other template nodes.

### 3.2 Common Section Types

Most prompts include some combination of these standard sections:

#### Context Section

Sets up the context and role for the LLM:

```typescript
get_Context_Section(): PromptTemplateNode<MY_PTH> {
    return new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'context',
        content: 'Context:',
        children: [
            `You are an AI financial analyst for ${this.static_args.company}.`,
            `Your task is to analyze the provided data and generate insights.`
        ]
    });
}
```

#### Rules Section

Defines rules and constraints for the LLM's response:

```typescript
get_Rules_Section(): PromptTemplateNode<MY_PTH> {
    return new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'rule',
        content: 'Rules:',
        children: [
            new PromptTemplateListNode<MY_PTH>({
                semantic_type: 'rule',
                children: [
                    `Always cite specific sources that inform your analysis.`,
                    `Use proper formatting for all output.`,
                    `Explain your reasoning clearly.`
                ],
                list_label_function: (_req, _child, idx) => `${idx + 1}. `
            })
        ]
    });
}
```

#### Schema Section

Defines the expected output structure:

```typescript
get_Schema_Section(): PromptTemplateNode<MY_PTH> {
    const schema_section = new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'schema',
        content: 'Schema:',
        children: []
    });
    
    // Add schema nodes here
    
    return schema_section;
}
```

#### Example Section

Provides examples of expected inputs and outputs:

```typescript
get_Example_Section(): PromptTemplateNode<MY_PTH> {
    return new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'sample_output',
        content: 'Example:',
        children: [
            new PromptTemplateCodeBoxNode<MY_PTH>({
                content: 'Example Input:',
                children: ['Show me the monthly sales for Q1.']
            }),
            new PromptTemplateCodeBoxNode<MY_PTH>({
                options: { struct_data_language: 'json' },
                content: 'Example Output:',
                children: [
                    new PromptTemplateStructDataNode<MY_PTH>({
                        data: exampleOutput
                    })
                ]
            })
        ]
    });
}
```

### 3.3 Conditional Content Using Conditions

You can make any section or node conditional using the `condition` property:

```typescript
new PromptTemplateTextNode<MY_PTH>({
    semantic_type: 'context',
    content: `The data includes chart PNGs that you should reference.`,
    condition: (request: PromptNodeRequest<MY_PTH>) => 
        request.args.input_working_memory_paths?.some(path => path.endsWith('.png')) ?? false
})
```

This allows you to include content only when certain conditions are met, making your prompts adaptive to the input context.

## 4. Prompt Node Types and Their Uses

The framework provides several specialized node types for different content needs:

### 4.1 Text Nodes for Simple Content

`PromptTemplateTextNode` is used for simple text content:

```typescript
new PromptTemplateTextNode<MY_PTH>({
    semantic_type: 'context',
    content: `You are an AI assistant for financial analysis.`
})
```

The content can also be a function that returns a string:

```typescript
new PromptTemplateTextNode<MY_PTH>({
    semantic_type: 'context',
    content: (request: PromptNodeRequest<MY_PTH>) => 
        `You are analyzing data for ${request.args.company_name}.`
})
```

### 4.2 List Nodes for Enumeration

`PromptTemplateListNode` is used for creating lists:

```typescript
new PromptTemplateListNode<MY_PTH>({
    semantic_type: 'rule',
    content: 'Follow these rules:',
    children: [
        `Always cite your sources.`,
        `Use proper formatting.`,
        `Explain your reasoning.`
    ],
    list_label_function: (_req, _child, idx) => `${idx + 1}. `
})
```

The `list_label_function` allows you to customize the labeling of list items. Some common patterns:

```typescript
// Numbered list (1. 2. 3.)
list_label_function: (_req, _child, idx) => `${idx + 1}. `

// Bulleted list (- item)
list_label_function: () => '- '

// Lettered list (a. b. c.)
list_label_function: (_req, _child, idx) => `${String.fromCharCode(97 + idx)}. `
```

#### Dynamic List Children

Lists can also generate children dynamically using `children_function`:

```typescript
new PromptTemplateListNode<MY_PTH>({
    semantic_type: 'context',
    children_function: async (request: PromptNodeRequest<MY_PTH>) => {
        // Fetch or compute children dynamically
        const items = await fetchDynamicItems(request);
        return items.map(item => 
            new PromptTemplateTextNode<MY_PTH>({
                content: item.description
            })
        );
    },
    list_label_function: (_req, _child, idx) => `${idx + 1}. `
})
```

### 4.3 Code Box Nodes for Code Examples

`PromptTemplateCodeBoxNode` is used for code examples:

```typescript
new PromptTemplateCodeBoxNode<MY_PTH>({
    semantic_type: 'context',
    content: 'Example SQL query:',
    children: [
        `SELECT * FROM sales WHERE date BETWEEN '2023-01-01' AND '2023-03-31'`
    ],
    options: { struct_data_language: 'sql' }
})
```

The `struct_data_language` option specifies the language for syntax highlighting when rendered.

### 4.4 Schema Nodes for Structured Data

#### Using Zod Schemas

The framework integrates with Zod for schema validation and rendering:

```typescript
import { z } from 'zod';
import { withSchemaMetadata } from '../nodes/template/PromptTemplateSchemaNode.js';

// Define schemas with metadata
const OutputSchema = withSchemaMetadata(
    z.object({
        summary: z.string().describe('Brief summary of the analysis'),
        details: z.array(DetailSchema).describe('Detailed findings'),
        confidence: z.number().min(0).max(1).describe('Confidence score')
    }),
    'AnalysisOutput',
    'The main output structure for the analysis'
);

// Use in schema section
get_Schema_Section(): PromptTemplateNode<MY_PTH> {
    const schema_section = new PromptTemplateSectionNode<MY_PTH>({
        semantic_type: 'schema',
        content: 'Schema:',
        children: []
    });

    const schemaSetNode = new PromptTemplateSchemaSetNode<MY_PTH>({
        semantic_type: 'schema',
        content: "",
        children: []
    });

    // Add schemas to set
    schemaSetNode.addSchemas([
        OutputSchema,
        DetailSchema
    ]);

    schema_section.add_child(schemaSetNode);
    return schema_section;
}
```

The schemas are automatically rendered in a natural language format that's easy for LLMs to understand.

### 4.5 Structure Data Nodes for JSON/YAML/CSV

`PromptTemplateStructDataNode` is used for including structured data:

```typescript
new PromptTemplateStructDataNode<MY_PTH>({
    semantic_type: 'sample_output',
    data: (request: PromptNodeRequest<MY_PTH>) => exampleOutput,
    options: {
        struct_data_language: 'json',
        formatting: { space: 2 }
    }
})
```

#### CSV Support

The framework now supports CSV output with customizable options:

```typescript
new PromptTemplateStructDataNode<MY_PTH>({
    semantic_type: 'data',
    data: csvData, // Array of objects
    options: {
        struct_data_language: 'csv',
        csv_separator: ',',
        csv_headers: ['name', 'value', 'date'], // Optional: specify order
        csv_include_headers: true // Default: true
    }
})
```

## 5. Programmatic Control Flow

### 5.1 ForEach Node for Iteration

The `PromptTemplateForEachNode` allows you to iterate over arrays:

```typescript
new PromptTemplateForEachNode<MY_PTH>({
    array_property: (request: PromptNodeRequest<MY_PTH>) => request.args.items,
    iteration_variable_name: 'item',
    index_variable_name: 'index',
    children: [
        new PromptTemplateTextNode<MY_PTH>({
            content: (request: PromptNodeRequest<MY_PTH>) => 
                `${request.local_scope.index + 1}. ${request.local_scope.item.name}`
        })
    ]
})
```

The iteration variables are available in `request.local_scope` within child nodes.

### 5.2 IfElse Node for Conditional Logic

The `PromptTemplateIfElseNode` provides binary branching:

```typescript
new PromptTemplateIfElseNode<MY_PTH>({
    condition_func: (request: PromptNodeRequest<MY_PTH>) => 
        request.args.includeDetails === true,
    true_case: new PromptTemplateTextNode<MY_PTH>({
        content: 'Include detailed analysis with all supporting data.'
    }),
    false_case: new PromptTemplateTextNode<MY_PTH>({
        content: 'Provide a brief summary only.'
    })
})
```

### 5.3 Switch Node for Multi-way Branching

The `PromptTemplateSwitchNode` handles multiple cases:

```typescript
new PromptTemplateSwitchNode<MY_PTH, string>({
    expression_func: (request: PromptNodeRequest<MY_PTH>) => 
        request.args.analysisType,
    cases: {
        'financial': new PromptTemplateTextNode<MY_PTH>({
            content: 'Perform financial analysis focusing on revenue and costs.'
        }),
        'operational': new PromptTemplateTextNode<MY_PTH>({
            content: 'Analyze operational efficiency and process optimization.'
        }),
        'strategic': new PromptTemplateTextNode<MY_PTH>({
            content: 'Provide strategic insights and market positioning analysis.'
        })
    },
    default_case: new PromptTemplateTextNode<MY_PTH>({
        content: 'Perform general business analysis.'
    }),
    strict: false // If true, throws error when no case matches
})
```

## 6. Tool Integration

### 6.1 Tool Directive Nodes

The framework provides specialized nodes for instructing LLMs to use specific tools:

```typescript
new ToolDirectiveNode<MY_PTH>({
    tool_name: 'calculator',
    purpose: 'Calculate the compound annual growth rate',
    parameter_values_to_use: {
        initial_value: 1000000,
        final_value: 1500000,
        years: 3
    },
    specific_usage_instructions: 'Use this to calculate the CAGR for the revenue growth.'
})
```

### 6.2 SQL Tool Integration

For SQL-specific operations:

```typescript
new RunSqlToolDirectiveNode<MY_PTH>({
    purpose: 'Retrieve sales data for the specified period',
    parameter_values_to_use: {
        database_name: 'sales_db',
        database_type: 'postgresql'
    },
    specific_usage_instructions: 'Build a query to get monthly sales totals grouped by product category.'
})
```

## 7. Working Memory Integration

### 7.1 Enhanced WMPromptGroup

The `WMPromptGroup` provides sophisticated working memory integration:

```typescript
const wmGroup = new WMPromptGroup<MY_PTH>(
    [
        { name: 'system', prompt: systemPrompt },
        { name: 'task', prompt: taskPrompt }
    ],
    {
        // Filter which files to include
        filterPaths: (paths: string[]) => 
            paths.filter(path => path.endsWith('.ts') || path.endsWith('.json')),
        
        // Generate descriptions for files
        getDescription: (path: string) => {
            const filename = path.split('/').pop() || '';
            return `Content from ${filename}:`;
        },
        
        // Transform content before including
        contentTransformers: {
            ts: (content: string) => {
                // Remove imports from TypeScript files
                return content.replace(/^import .*$/gm, '');
            }
        },
        
        // Format metadata for images
        formatImageMetadata: (metadata: Record<string, any>) => {
            return `Image dimensions: ${metadata.width}x${metadata.height}`;
        }
    }
);
```

### 7.2 Working Memory Preprocessing

The WMPromptGroup preprocesses working memory items during the `init_preprocess` phase:

```typescript
export interface ProcessedWMItem {
    path: string;
    memoryId: string;
    description: string;
    isImage: boolean;
    metadata?: Record<string, any>; // For images
    content?: string; // For text-based content
    language?: string; // For syntax highlighting
}
```

This preprocessing improves performance by loading and transforming content once before rendering.

### 7.3 Working Memory Path Resolution

Helper methods for working with memory paths:

```typescript
// Helper to get chart names from working memory paths
protected get_chart_names(output_working_memory_paths?: string[]): string[] {
    const png_files = output_working_memory_paths?.filter(path => path.endsWith('.png'));
    return (png_files?.map(path => {
        const filename = path.split('/').pop() || '';
        return filename.replace('.png', '');
    }) || []).filter(name => name !== '');
}
```

## 8. Memory Tidbits for Context Persistence

### 8.1 Using MemoryTidbitPrompt

The `MemoryTidbitPrompt` includes context from previous interactions:

```typescript
const tidbitPrompt = new MemoryTidbitPrompt<MY_PTH>(
    'system',
    args,
    { preamble: 'Previous Context:' },
    ['fact', 'correction'], // Tidbit subtypes to include
    ['user_preference', 'domain_knowledge'] // Semantic purposes
);
```

### 8.2 Tidbit Types and Usage

Tidbits are categorized by subtype and semantic purpose:

- **Subtypes**: `'fact'`, `'note'`, `'correction'`
- **Semantic Purposes**: Custom strings like `'user_preference'`, `'domain_knowledge'`, etc.

The tidbits are automatically fetched and formatted in the prompt:

```json
{
  "fact": [
    {
      "semantic_purpose": "user_preference",
      "data": {
        "preference": "prefers detailed explanations",
        "context": "technical topics"
      }
    }
  ],
  "correction": [
    {
      "semantic_purpose": "domain_knowledge",
      "data": {
        "incorrect": "revenue is calculated quarterly",
        "correct": "revenue is calculated monthly"
      }
    }
  ]
}
```

## 9. Conditional Rendering

### 9.1 ConditionalPromptGroup

Render entire prompt groups conditionally:

```typescript
const conditionalGroup = new ConditionalPromptGroup<MY_PTH>(
    [
        { name: 'analysis', prompt: analysisPrompt },
        { name: 'recommendations', prompt: recommendationsPrompt }
    ],
    options,
    (request: PromptNodeRequest<MY_PTH>) => {
        // Only include if user has requested detailed analysis
        return request.args.includeAnalysis === true;
    }
);
```

### 9.2 Dynamic Condition Updates

Conditions can be updated dynamically:

```typescript
conditionalGroup.setCondition((request: PromptNodeRequest<MY_PTH>) => {
    return request.args.mode === 'advanced';
});
```

## 10. Advanced Techniques

### 10.1 Prompt Groups for Complex Interactions

For complex prompt patterns like chat interfaces:

```typescript
export default class ChatPromptGroup extends PromptGroup<CHAT_PTH> {
    constructor() {
        super([
            {
                name: 'system',
                prompt: new SystemPrompt(/* args */)
            },
            {
                name: 'chat_history',
                prompt: new ChatHistoryPrompt(/* args */)
            },
            {
                name: 'user_input',
                prompt: new UserInputPrompt(/* args */)
            }
        ]);
    }
}
```

### 10.2 Error Handling

For handling errors in complex workflows:

```typescript
export class CompilerErrorPrompt extends ErrorPromptBase<COMPILER_ERROR_PTH> {
    constructor(args: COMPILER_ERROR_PTH['args']['static'], options?: COMPILER_ERROR_PTH['options']) {
        super('system', args, options);
        this.add_section(this.get_CompilerError_System_Section());
        this.add_section(this.createTypeScriptErrorInstructions<COMPILER_ERROR_PTH>('rule'));
    }

    get_CompilerError_System_Section(): PromptTemplateNode<COMPILER_ERROR_PTH> {
        const section = new PromptTemplateSectionNode<COMPILER_ERROR_PTH>({
            semantic_type: 'error',
            children: [
                new PromptTemplateTextNode<COMPILER_ERROR_PTH>({
                    semantic_type: 'context',
                    content: `You are a TypeScript expert. Analyze the compiler error(s) and fix the code.`
                })
            ]
        });
        
        return section;
    }
}
```

### 10.3 Progress Tracking and Streaming

For long-running operations with progress tracking:

```typescript
async *generatePrompt(request: PromptNodeRequest<MY_PTH>): AsyncGenerator<
    ProgressUpdate,
    CompletedResult,
    undefined
> {
    // Yield status update
    yield { 
        type: 'STATUS', 
        status: 'STARTED', 
        message: 'Starting prompt generation' 
    };
    
    try {
        // Perform initialization
        yield { 
            type: 'STATUS', 
            status: 'PROCESSING', 
            message: 'Processing input data' 
        };
        
        // Generate prompt content
        const result = await this.generate(request);
        
        // Return final result
        return result;
    } catch (error) {
        // Yield error
        yield { 
            type: 'ERROR', 
            error: error as Error 
        };
        throw error;
    }
}
```

### 10.4 Utility Prompts

The framework provides several utility prompt classes:

```typescript
// Simple system prompt with text
const systemPrompt = new PromptBasicSystem<MY_PTH>(
    'You are an AI assistant specialized in data analysis.',
    args,
    options
);

// Structured data input
const dataPrompt = new PromptInputStructData<MY_PTH>(
    args,
    {
        use_code_block: true,
        preamble: 'Analyze the following data:',
        data: inputData
    }
);

// Error handling
const errorGroup = new PromptGroupDefaultError<ERROR_PTH>(
    args,
    options
);
```

## 11. Best Practices

### 11.1 Organizational Patterns

Organize your prompts using these patterns:

1. **Section-Based Organization**: Divide your prompt into logical sections (context, rules, examples, etc.)

2. **Inheritance for Common Patterns**: Use inheritance to share common sections and logic

3. **Composition for Complex Prompts**: Build complex prompts by composing smaller, reusable components

4. **Helper Methods for Common Patterns**: Create helper methods for common content patterns

### 11.2 Performance Considerations

Keep performance in mind when building complex prompts:

1. **Minimize Preprocessing**: Avoid heavy processing in `preprocess` methods

2. **Lazy Loading**: Use functions to generate content only when needed

3. **Caching**: Cache expensive operations in the request state

4. **Conditional Rendering**: Use conditions to skip sections that aren't needed

5. **Preprocessing Working Memory**: Use `init_preprocess` for loading working memory once

### 11.3 Testing and Debugging

Test and debug your prompts effectively:

1. **Unit Tests**: Write tests for individual sections and components

2. **Integration Tests**: Test the full prompt rendering pipeline

3. **Logging**: Use console logging to debug prompt generation

4. **Incremental Development**: Build and test one section at a time

### 11.4 Type Safety Best Practices

1. **Define Clear Types**: Always define clear input and argument types

2. **Use PromptTypeHelper**: Leverage the type helper for consistency

3. **Avoid Any Types**: Use specific types instead of `any` where possible

4. **Type Guards**: Use type guards for runtime type checking

## 12. Example Prompt Walkthroughs

### 12.1 Data Analysis Prompt with Conditional Sections

```typescript
type ANALYSIS_INPUT = {
    data: any[];
    query: string;
};

type ANALYSIS_ARGS = {
    static: {
        company: string;
        analysisType: 'detailed' | 'summary';
    };
    request: {
        includeCharts?: boolean;
        outputFormat?: 'json' | 'csv';
        chartPaths?: string[];
    };
};

export type ANALYSIS_PTH = PromptTypeHelper<ANALYSIS_INPUT, ANALYSIS_ARGS>;

export class DataAnalysisPrompt extends Prompt<ANALYSIS_PTH> {
    constructor(args: ANALYSIS_PTH['args']['static'], options?: ANALYSIS_PTH['options']) {
        super('system', args, options);
        this.add_section(this.get_Context_Section());
        this.add_section(this.get_Data_Section());
        this.add_section(this.get_Analysis_Instructions());
        this.add_section(this.get_Output_Format());
    }

    get_Context_Section(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSectionNode<ANALYSIS_PTH>({
            semantic_type: 'context',
            content: 'Context:',
            children: [
                `You are a data analyst for ${this.static_args.company}.`,
                new PromptTemplateTextNode<ANALYSIS_PTH>({
                    content: (request) => 
                        this.static_args.analysisType === 'detailed' 
                            ? 'Provide comprehensive analysis with all supporting details.'
                            : 'Provide a concise summary of key findings.',
                })
            ]
        });
    }

    get_Data_Section(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSectionNode<ANALYSIS_PTH>({
            semantic_type: 'context',
            content: 'Data to Analyze:',
            children: [
                new PromptTemplateStructDataNode<ANALYSIS_PTH>({
                    data: (request) => request.input.data,
                    options: {
                        struct_data_language: 'json',
                        formatting: { space: 2 }
                    }
                })
            ]
        });
    }

    get_Analysis_Instructions(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSectionNode<ANALYSIS_PTH>({
            semantic_type: 'rule',
            content: 'Analysis Instructions:',
            children: [
                new PromptTemplateTextNode<ANALYSIS_PTH>({
                    content: (request) => `User Query: ${request.input.query}`
                }),
                new PromptTemplateIfElseNode<ANALYSIS_PTH>({
                    condition_func: (request) => request.args.includeCharts === true,
                    true_case: new PromptTemplateListNode<ANALYSIS_PTH>({
                        content: 'Chart Requirements:',
                        children: [
                            'Create visualizations for key metrics',
                            'Reference charts using their IDs',
                            'Explain what each chart shows'
                        ],
                        list_label_function: () => 'â€¢ '
                    })
                })
            ]
        });
    }

    get_Output_Format(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSwitchNode<ANALYSIS_PTH, string>({
            expression_func: (request) => request.args.outputFormat || 'json',
            cases: {
                'json': new PromptTemplateTextNode<ANALYSIS_PTH>({
                    content: 'Output your analysis as a JSON object with keys: summary, findings, recommendations'
                }),
                'csv': new PromptTemplateTextNode<ANALYSIS_PTH>({
                    content: 'Output your analysis as a CSV with columns: metric, value, trend, insight'
                })
            }
        });
    }
}
```

### 12.2 Interactive Chat with Memory

```typescript
type CHAT_INPUT = string;
type CHAT_ARGS = {
    static: {
        assistantName?: string;
    };
    request: {
        sessionId: string;
        includeMemory?: boolean;
    };
};

export type CHAT_PTH = PromptTypeHelper<CHAT_INPUT, CHAT_ARGS>;

export class InteractiveChatPrompt extends PromptGroup<CHAT_PTH> {
    constructor(args: CHAT_ARGS['static'], options?: CHAT_PTH['options']) {
        const prompts = [
            {
                name: 'system',
                prompt: new SystemContextPrompt(args, options)
            },
            {
                name: 'memory',
                prompt: new ConditionalPromptGroup<CHAT_PTH>(
                    [{
                        name: 'tidbits',
                        prompt: new MemoryTidbitPrompt<CHAT_PTH>(
                            'system',
                            args,
                            { preamble: 'Context from previous conversations:' },
                            ['fact', 'note', 'correction'],
                            ['user_preference', 'conversation_context']
                        )
                    }],
                    options,
                    (request) => request.args.includeMemory === true
                )
            },
            {
                name: 'history',
                prompt: new PromptGroupChatHistory<CHAT_PTH>()
            },
            {
                name: 'input',
                prompt: new PromptInputText<CHAT_PTH>(args, options)
            }
        ];
        
        super(prompts, options);
    }
}

class SystemContextPrompt extends Prompt<CHAT_PTH> {
    constructor(args: CHAT_ARGS['static'], options?: CHAT_PTH['options']) {
        super('system', args, options);
        this.add_section(this.get_System_Section());
    }

    get_System_Section(): PromptTemplateNode<CHAT_PTH> {
        return new PromptTemplateSectionNode<CHAT_PTH>({
            semantic_type: 'context',
            children: [
                `You are ${this.static_args.assistantName || 'an AI assistant'}.`,
                'Maintain context across the conversation.',
                'Be helpful, accurate, and engaging.'
            ]
        });
    }
}
```

### 12.3 Tool-Integrated Analysis Prompt

```typescript
export class ToolIntegratedAnalysisPrompt extends Prompt<ANALYSIS_PTH> {
    constructor(args: ANALYSIS_PTH['args']['static'], options?: ANALYSIS_PTH['options']) {
        super('system', args, options);
        this.add_section(this.get_Context_Section());
        this.add_section(this.get_Available_Tools());
        this.add_section(this.get_Task_Section());
    }

    get_Available_Tools(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSectionNode<ANALYSIS_PTH>({
            semantic_type: 'context',
            content: 'Available Tools:',
            children: [
                new PromptTemplateForEachNode<ANALYSIS_PTH>({
                    array_property: [
                        { name: 'runSql', db: 'analytics_db' },
                        { name: 'calculator', purpose: 'complex calculations' },
                        { name: 'chart_generator', types: ['bar', 'line', 'pie'] }
                    ],
                    iteration_variable_name: 'tool',
                    index_variable_name: 'idx',
                    children: [
                        new RunSqlToolDirectiveNode<ANALYSIS_PTH>(
                            {
                                purpose: 'Query analytics database',
                                parameter_values_to_use: {
                                    database_name: 'analytics_db',
                                    database_type: 'postgresql'
                                }
                            },
                            {
                                condition: (request) => 
                                    request.local_scope.tool.name === 'runSql'
                            }
                        ),
                        new ToolDirectiveNode<ANALYSIS_PTH>(
                            {
                                tool_name: 'calculator',
                                purpose: 'Perform complex calculations',
                                specific_usage_instructions: 'Use for statistical analysis and financial metrics'
                            },
                            {
                                condition: (request) => 
                                    request.local_scope.tool.name === 'calculator'
                            }
                        )
                    ]
                })
            ]
        });
    }

    get_Task_Section(): PromptTemplateNode<ANALYSIS_PTH> {
        return new PromptTemplateSectionNode<ANALYSIS_PTH>({
            semantic_type: 'context',
            content: 'Task:',
            children: [
                'Use the available tools to gather and analyze data.',
                'Provide insights based on the analysis.',
                'Create visualizations where appropriate.'
            ]
        });
    }
}
```

## Conclusion

The FireFoundry Prompting Framework provides a powerful, flexible system for creating structured prompts for large language models. By separating structure from content and leveraging template-based composition, it enables sophisticated AI workflows while maintaining clear organization and extensibility.

Key takeaways:

1. **Use the Type System**: Leverage TypeScript's type system with `PromptTypeHelper` for robust prompt development.

2. **Organize by Sections**: Divide prompts into logical sections for better organization and maintenance.

3. **Leverage Dynamic Content**: Use functions to generate content based on request context and state.

4. **Template and Reuse**: Create reusable components through inheritance and composition.

5. **Working Memory Integration**: Utilize working memory to access and reference files and artifacts from previous steps.

6. **Programmatic Control**: Use ForEach, IfElse, and Switch nodes for dynamic prompt generation.

7. **Tool Integration**: Direct LLMs to use specific tools with required parameters.

8. **Memory Persistence**: Include context from previous interactions through memory tidbits.

9. **Conditional Rendering**: Control what gets included based on runtime conditions.

10. **Performance Optimization**: Use preprocessing and caching for better performance.

By following the patterns and practices in this guide, you can create sophisticated, maintainable prompts that leverage the full power of the FireFoundry SDK.